{
	"appsUsed":[
		
	],
	"createdTime":1760614864778,
	"deleted":false,
	"edges":[
		{
			"fromNodeId":"n_JHETh",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KSDkd",
			"type":"next"
		},
		{
			"fromNodeId":"n_KSDkd",
			"priority":0,
			"skip":false,
			"toNodeId":"_4Jeol",
			"type":"next"
		},
		{
			"fromNodeId":"_4Jeol",
			"priority":0,
			"skip":false,
			"toNodeId":"_eXQK8",
			"type":"next"
		},
		{
			"fromNodeId":"_eXQK8",
			"priority":0,
			"skip":false,
			"toNodeId":"_2vG2F",
			"type":"next"
		},
		{
			"fromNodeId":"_2vG2F",
			"priority":0,
			"skip":false,
			"toNodeId":"n_BxGyJ",
			"type":"next"
		},
		{
			"fromNodeId":"n_BxGyJ",
			"name":"1",
			"priority":0,
			"skip":false,
			"toNodeId":"n_BxGyJ@1",
			"type":"branch"
		},
		{
			"fromNodeId":"n_BxGyJ@1",
			"priority":0,
			"skip":false,
			"toNodeId":"_8vNQO",
			"type":"next"
		},
		{
			"fromNodeId":"_8vNQO",
			"priority":0,
			"skip":false,
			"toNodeId":"_LPBQO",
			"type":"next"
		},
		{
			"fromNodeId":"_LPBQO",
			"priority":0,
			"skip":false,
			"toNodeId":"n_gQ3ri",
			"type":"next"
		},
		{
			"fromNodeId":"n_BxGyJ",
			"name":"2",
			"priority":0,
			"skip":false,
			"toNodeId":"n_BxGyJ@2",
			"type":"branch"
		},
		{
			"fromNodeId":"n_BxGyJ@2",
			"priority":0,
			"skip":false,
			"toNodeId":"_D8Moe",
			"type":"next"
		},
		{
			"fromNodeId":"_D8Moe",
			"priority":0,
			"skip":false,
			"toNodeId":"_1UplZ",
			"type":"next"
		},
		{
			"fromNodeId":"_1UplZ",
			"priority":0,
			"skip":false,
			"toNodeId":"_MyKIq",
			"type":"next"
		},
		{
			"fromNodeId":"n_BxGyJ",
			"name":"3",
			"priority":0,
			"skip":false,
			"toNodeId":"n_BxGyJ@3",
			"type":"branch"
		},
		{
			"fromNodeId":"n_BxGyJ@3",
			"priority":0,
			"skip":false,
			"toNodeId":"_sdiv9",
			"type":"next"
		},
		{
			"fromNodeId":"_sdiv9",
			"priority":0,
			"skip":false,
			"toNodeId":"_LjaEI",
			"type":"next"
		},
		{
			"fromNodeId":"_LjaEI",
			"priority":0,
			"skip":false,
			"toNodeId":"_61TkJ",
			"type":"next"
		},
		{
			"fromNodeId":"n_BxGyJ",
			"name":"4",
			"priority":0,
			"skip":false,
			"toNodeId":"n_BxGyJ@4",
			"type":"branch"
		},
		{
			"fromNodeId":"n_BxGyJ@4",
			"priority":0,
			"skip":false,
			"toNodeId":"_okOsh",
			"type":"next"
		},
		{
			"fromNodeId":"_okOsh",
			"priority":0,
			"skip":false,
			"toNodeId":"_DciO8",
			"type":"next"
		},
		{
			"fromNodeId":"_DciO8",
			"priority":0,
			"skip":false,
			"toNodeId":"_4a3AQ",
			"type":"next"
		},
		{
			"fromNodeId":"n_gQ3ri",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KQyKt",
			"type":"next"
		},
		{
			"fromNodeId":"_MyKIq",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KQyKt",
			"type":"next"
		},
		{
			"fromNodeId":"_61TkJ",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KQyKt",
			"type":"next"
		},
		{
			"fromNodeId":"_4a3AQ",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KQyKt",
			"type":"next"
		},
		{
			"fromNodeId":"n_BxGyJ",
			"name":"default",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KQyKt",
			"type":"branch"
		}
	],
	"id":"68e3c0671d3efd6f233ca9dd",
	"lastModifiedBy":30179,
	"lcName":"oman | provider search | count",
	"modifiedTime":1760614864778,
	"name":"Oman | Provider Search | Count",
	"nodes":[
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				}
			},
			"context":{
				"appName":"callables",
				"resourceVersion":12,
				"resourceName":"callables_from_automation"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"n_JHETh",
			"index":1,
			"inputs":{
				"result":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"total_hospital_records_in_search":{
							"type":"integer",
							"title":"total_hospital_records_in_search"
						},
						"total_clinic_records_in_search":{
							"type":"integer",
							"title":"total_clinic_records_in_search"
						},
						"total_pharmacy_records_in_search":{
							"type":"integer",
							"title":"total_pharmacy_records_in_search"
						},
						"total_diagnostic_records_in_search":{
							"type":"integer",
							"title":"total_diagnostic_records_in_search"
						}
					}
				},
				"setup":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"provider_type":{
							"type":"string",
							"title":"Provider Type"
						},
						"city":{
							"type":"string",
							"title":"City"
						},
						"governorte":{
							"type":"string",
							"title":"Governorte"
						},
						"Country":{
							"type":"string",
							"title":"Country"
						},
						"Area":{
							"type":"string",
							"title":"Area"
						},
						"speciality":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Speciality"
						},
						"opening_hrs":{
							"type":"string",
							"title":"Opening Hrs"
						},
						"search":{
							"type":"string",
							"title":"Search"
						},
						"latitude":{
							"type":"number",
							"title":"Latitude"
						},
						"longitude":{
							"type":"number",
							"title":"Longitude"
						},
						"day":{
							"type":"string",
							"title":"Day"
						},
						"time":{
							"type":"string",
							"title":"Time"
						},
						"tab":{
							"type":"string",
							"title":"Tab"
						},
						"member_id":{
							"type":"string",
							"title":"Member Id"
						},
						"range_start":{
							"type":"string",
							"title":"Range start"
						},
						"range_end":{
							"type":"string",
							"title":"Range End"
						},
						"pageSize":{
							"type":"number",
							"title":"Page Size"
						},
						"offset":{
							"type":"number",
							"title":"Offset"
						},
						"currentPage":{
							"type":"number",
							"title":"Current Page"
						},
						"total":{
							"type":"number",
							"title":"Total"
						}
					}
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via automation",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"n_KSDkd",
			"index":2,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_hospital_records_in_search":{
							"type":"integer",
							"title":"total_hospital_records_in_search"
						}
					},
					"required":[]
				}
			},
			"inputs":{},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_hospital_records_in_search":{
							"type":"integer",
							"title":"total_hospital_records_in_search"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"_4Jeol",
			"index":3,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_clinics_records_in_search":{
							"type":"integer",
							"title":"total_clinics_records_in_search"
						}
					},
					"required":[]
				}
			},
			"inputs":{},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_clinics_records_in_search":{
							"type":"integer",
							"title":"total_clinics_records_in_search"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"_eXQK8",
			"index":4,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_pharmacy_records_in_search":{
							"type":"integer",
							"title":"total_pharmacy_records_in_search"
						}
					},
					"required":[]
				}
			},
			"inputs":{},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_pharmacy_records_in_search":{
							"type":"integer",
							"title":"total_pharmacy_records_in_search"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"_2vG2F",
			"index":5,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_diagnostic_records_in_search":{
							"type":"integer",
							"title":"total_diagnostic_records_in_search"
						}
					},
					"required":[]
				}
			},
			"inputs":{},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"total_diagnostic_records_in_search":{
							"type":"integer",
							"title":"total_diagnostic_records_in_search"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"branch",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"n_BxGyJ",
			"index":6,
			"inputs":{
				"branches":[
					{
						"id":"1",
						"inputs":{
							"name":"Branch 1",
							"conditions":{
								"filters":[
									{
										"property":"1",
										"filter":{
											"operator":"EQUAL",
											"value":"1"
										}
									}
								],
								"operator":"AND"
							}
						}
					},
					{
						"id":"2",
						"inputs":{
							"name":"Branch 2",
							"conditions":{
								"filters":[
									{
										"property":"1",
										"filter":{
											"operator":"EQUAL",
											"value":"1"
										}
									}
								],
								"operator":"AND"
							}
						}
					},
					{
						"id":"3",
						"inputs":{
							"name":"Branch 3",
							"conditions":{
								"filters":[
									{
										"property":"1",
										"filter":{
											"operator":"EQUAL",
											"value":"1"
										}
									}
								],
								"operator":"AND"
							}
						}
					},
					{
						"id":"4",
						"inputs":{
							"name":"Branch 4",
							"conditions":{
								"filters":[
									{
										"property":"1",
										"filter":{
											"operator":"EQUAL",
											"value":"1"
										}
									}
								],
								"operator":"AND"
							}
						}
					},
					{
						"id":"default"
					}
				]
			},
			"skip":false,
			"subTitle":"Branch",
			"title":"",
			"type":"BRANCH"
		},
		{
			"context":{
				"appName":"branch_condition",
				"resourceVersion":0,
				"resourceName":"branch_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@1",
			"id":"n_BxGyJ@1",
			"index":7,
			"inputs":{
				"name":"Branch 1",
				"conditions":{
					"filters":[
						{
							"property":"1",
							"filter":{
								"operator":"EQUAL",
								"value":"1"
							}
						}
					],
					"operator":"AND"
				}
			},
			"skip":false,
			"title":"",
			"type":"BRANCH_CONDITION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				}
			},
			"context":{
				"appName":"analytics_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"analytics_by_unifyapps_execute_query",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@1",
			"id":"_8vNQO",
			"index":8,
			"inputs":{
				"outputSchema":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"total_records"
					],
					"properties":{
						"ProviderID":{
							"type":"string",
							"title":"ProviderID"
						},
						"Speciality":{
							"type":"string",
							"title":"Speciality"
						},
						"Address":{
							"type":"string",
							"title":"Address"
						},
						"medicineDelivery":{
							"type":"string",
							"title":"medicineDelivery"
						},
						"latitude":{
							"type":"number",
							"title":"latitude"
						},
						"FeaturedProvider":{
							"type":"string",
							"title":"FeaturedProvider"
						},
						"SpecialityDetails":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"SpecialityDetails"
						},
						"Band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"City":{
							"type":"string",
							"title":"City"
						},
						"Longitude":{
							"type":"number",
							"title":"Longitude"
						},
						"weekdayDescriptions":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"time":{
										"type":"string",
										"title":"time"
									},
									"day":{
										"type":"string",
										"title":"day"
									}
								},
								"additionalProperties":false
							},
							"title":"weekdayDescriptions"
						},
						"ProviderName":{
							"type":"string",
							"title":"ProviderName"
						},
						"Governarate_Area":{
							"type":"string",
							"title":"Governarate_Area"
						},
						"mapsURL":{
							"type":"string",
							"title":"mapsURL"
						},
						"Country":{
							"type":"string",
							"title":"Country"
						},
						"ContactNumber":{
							"type":"string",
							"title":"ContactNumber"
						},
						"ProviderType":{
							"type":"string",
							"title":"ProviderType"
						},
						"favorite":{
							"type":"string",
							"title":"Favorite"
						},
						"Deleted_fav":{
							"type":"string",
							"title":"Deleted Fav"
						},
						"total_records":{
							"type":"string",
							"title":"Total Records"
						}
					}
				},
				"query":"SELECT\n  np._pr_Longitude, np._pr_Latitude, np._pr_ProviderType, np.id\nFROM ENTITY_oman_network_providers np\nWHERE deleted = false AND\n  LOWER(np._pr_ProviderType) = LOWER('Hospitals')\n  AND ('{{ n_JHETh.outputs.city }}' IS NULL OR '{{ n_JHETh.outputs.city }}' = '' OR LOWER(np._pr_City) = LOWER('{{ n_JHETh.outputs.city }}'))\n  AND ('{{ n_JHETh.outputs.Area }}' IS NULL OR '{{ n_JHETh.outputs.Area }}' = '' OR LOWER(np._pr_Governarate_Area) = LOWER('{{ n_JHETh.outputs.Area }}'))\n  AND ('{{ n_JHETh.outputs.Country }}' IS NULL OR '{{ n_JHETh.outputs.Country }}' = '' OR LOWER(np._pr_Country) = LOWER('{{ n_JHETh.outputs.Country }}'))\n  AND ('{{ n_JHETh.outputs.search }}' IS NULL OR '{{ n_JHETh.outputs.search }}' = '' OR LOWER(np._pr_ProviderName) LIKE LOWER('%{{ n_JHETh.outputs.search }}%') OR LOWER(np._pr_Speciality) LIKE LOWER('%{{ n_JHETh.outputs.search }}%'))\n  AND ('{{ n_JHETh.outputs.tab }}' IS NULL OR '{{ n_JHETh.outputs.tab }}' = '' OR LOWER(np._pr_ProviderType) = LOWER('{{ n_JHETh.outputs.tab }}'));\n",
				"group":"ENTITY_REPORTING"
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false,
					"slidingWindowType":"COUNT_BASED"
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"unit":"MINUTES",
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Analytics by UnifyApps",
			"title":"Execute Analytics SQL Query",
			"type":"ACTION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				},
				"visibleOptionalFields":[
					"root.parameters.band.items",
					"root.parameters.speciality.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@1",
			"id":"_LPBQO",
			"index":9,
			"inputs":{
				"output":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"countHospitals"
					],
					"properties":{
						"countHospitals":{
							"type":"integer",
							"title":"Count Hospitals"
						}
					}
				},
				"input":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"data":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Data"
						},
						"speciality":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Speciality"
						},
						"distance":{
							"type":"string",
							"title":"Distance"
						},
						"openinghrs":{
							"type":"string",
							"title":"openinghrs"
						},
						"day":{
							"type":"string",
							"title":"Day"
						},
						"time":{
							"type":"string",
							"title":"Time"
						},
						"latitude":{
							"type":"string",
							"title":"Latitude"
						},
						"longitude":{
							"type":"string",
							"title":"Longitude"
						},
						"range_start":{
							"type":"string",
							"title":"Range Start"
						},
						"range_end":{
							"type":"string",
							"title":"Range End"
						}
					}
				},
				"code":"// ---------- Early exit for SQL \"no rows\" ----------\ndef d0 = (binding?.hasVariable('data')) ? data : null\nif (d0 instanceof Map && d0.size() == 1 && d0.containsKey('hasMore')) {\n    return d0 // {\"result\":{\"hasMore\":false}}\n}\n\n// ---------- Load rows ----------\ndef src = (d0 instanceof Collection) ? d0 as List\n         : (d0 instanceof Map       ) ? [d0]\n         : []\nif (src.isEmpty()) return []\n\n// ---------- Constants ----------\nfinal double EARTH_R_KM = 6371.0088d\n\n// ---------- Get current Oman time ----------\nimport java.time.*\nimport java.time.format.*\n\ndef omanZone = ZoneId.of(\"Asia/Muscat\")\ndef omanNow = ZonedDateTime.now(omanZone)\nfinal String CURRENT_DAY = omanNow.getDayOfWeek().getDisplayName(java.time.format.TextStyle.FULL, Locale.ENGLISH)\nfinal String CURRENT_TIME = omanNow.format(DateTimeFormatter.ofPattern(\"h:mm a\"))\n\n// ---------- Small helpers ----------\ndef asList  = { v -> (v == null) ? [] : (v instanceof Collection ? v as List : [v]) }\ndef trimLC  = { s -> s?.toString()?.trim()?.toLowerCase() }\ndef toDbl   = { v ->\n    if (v == null) return null\n    if (v instanceof Number) return ((Number)v).doubleValue()\n    def s = v.toString().trim()\n    if (!s || s.equalsIgnoreCase('null') || s.equalsIgnoreCase('na')) return null\n    try { return Double.parseDouble(s) } catch (ignored) { return null }\n}\ndef getF = { Map m, List keys -> for (k in keys) { if (m.containsKey(k) && m[k] != null) return m[k] }; return null }\n\n// ---------- Use input origin (latitude/longitude) WITHOUT fallback ----------\ndef ORIGIN_LAT = toDbl(binding?.hasVariable('latitude') ? latitude : -1)\ndef ORIGIN_LON = toDbl(binding?.hasVariable('longitude') ? longitude : -1)\n\n// ---------- Normalize / JSON-ish parsing (no JsonSlurper) ----------\ndef normalizeStr = { String s ->\n    if (s == null) return \"\"\n    s.replaceAll(\"[\\u2013\\u2014\\u2212]\", \"-\")\n     .replaceAll(\"[\\u2009\\u202F\\u00A0]\", \" \")\n     .replaceAll(\"\\\\s*,\\\\s*\", \",\")\n     .replaceAll(\"\\\\s*-\\\\s*\", \"-\")\n     .replaceAll(\"\\\\s+\", \" \")\n     .trim()\n}\ndef coercePrimitive = { String t ->\n    if (t == null) return null\n    def x = t.trim()\n    if (!x) return \"\"\n    if ((x.startsWith('\"') && x.endsWith('\"')) || (x.startsWith(\"'\") && x.endsWith(\"'\"))) {\n        x = x.substring(1, x.length()-1)\n    }\n    if (x.equalsIgnoreCase(\"true\"))  return true\n    if (x.equalsIgnoreCase(\"false\")) return false\n    if (x.equalsIgnoreCase(\"yes\"))   return true\n    if (x.equalsIgnoreCase(\"no\"))    return false\n    if (x ==~ /^-?\\d+$/)             return Long.parseLong(x)\n    if (x ==~ /^-?\\d+\\.\\d+$/)        return Double.parseDouble(x)\n    return x\n}\ndef parseArrayGeneric = { String arr ->\n    String s = arr?.trim() ?: \"\"\n    if (!s.startsWith(\"[\") || !s.endsWith(\"]\")) return s\n\n    if (s.contains(\"{\")) {\n        def blocks = (s =~ /\\{[^}]*\\}/)\n        def out = []\n        blocks.each { m -> out << parseObjectGeneric(m[0]) }\n        if (!out.isEmpty()) return out\n    }\n\n    def tokens = []\n    def qt = (s =~ /\"(.*?)\"|'(.*?)'/)\n    qt.each { _, g1, g2 -> tokens << (g1 ?: g2) }\n    if (!tokens.isEmpty()) return tokens.collect { coercePrimitive(it) }\n\n    def inner = s.substring(1, s.length()-1)\n    return inner.split(/\\s*,\\s*/).findAll { it != null && it.trim() }.collect { coercePrimitive(it) }\n}\ndef parseObjectGeneric = { String obj ->\n    String o = obj?.trim() ?: \"\"\n    if (!o.startsWith(\"{\") || !o.endsWith(\"}\")) return o\n    def map = [:]\n\n    def arrRe = (o =~ /\"([^\"]+)\"\\s*:\\s*(\\[[^\\]]*\\])/)\n    arrRe.each { m -> map[m[1]] = parseArrayGeneric(m[2]) }\n\n    def strRe = (o =~ /\"([^\"]+)\"\\s*:\\s*\"([^\"]*)\"/)\n    strRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2] }\n\n    def numRe = (o =~ /\"([^\"]+)\"\\s*:\\s*([-]?\\d+(?:\\.\\d+)?)/)\n    numRe.each { m ->\n        if (!map.containsKey(m[1])) map[m[1]] = (m[2].contains('.') ? Double.parseDouble(m[2]) : Long.parseLong(m[2]))\n    }\n\n    def boolRe = (o =~ /\"([^\"]+)\"\\s*:\\s*((?i:true|false))/)\n    boolRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2].equalsIgnoreCase(\"true\") }\n\n    return map\n}\ndef parseStringArray = { v ->\n    if (v == null) return []\n    if (v instanceof Collection) return v.collect { it?.toString() }\n    def s = v.toString().trim(); if (!s) return []\n    if ((s.startsWith('[') && s.endsWith(']')) || (s.startsWith('(') && s.endsWith(')'))) {\n        def u = s.contains('\\\\\\\"') ? s.replace('\\\\\\\"','\"') : s\n        def toks = []\n        def m = (u =~ /\"(.*?)\"|'(.*?)'/)\n        m.each { _, g1, g2 -> def tok = (g1 ?: g2); if (tok != null && tok.trim()) toks << tok }\n        if (toks.isEmpty()) {\n            def inner = u.substring(1, u.length()-1)\n            toks = inner.split(/\\s*,\\s*|\\s*\\|\\s*/)\n        }\n        return toks.collect { it?.toString() }\n    }\n    return s.split(/\\s*,\\s*|\\s*\\|\\s*/).collect { it?.toString() }\n}\n\n// ---------- Hours ----------\ndef toWeekdayList = { Object wd ->\n    if (wd == null) return []\n    if (wd instanceof Collection) {\n        return wd.collect { it instanceof Map ? [day: it.day?.toString(), time: it.time?.toString()] : it }\n    }\n    String u = wd.toString().trim()\n    if (!u) return []\n    if (u.contains('\\\\\\\"')) u = u.replace('\\\\\\\"','\"')\n    def blocks = (u =~ /\\{[^}]*\\}/)\n    def out = []\n    blocks.each { m ->\n        String ob = m[0]\n        def dm = (ob =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n        def tm = (ob =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n        if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n    }\n    if (out.isEmpty() && u.startsWith('[') && u.endsWith(']')) {\n        def parts = u.substring(1, u.length()-1).split(/}\\s*,\\s*\\{/)\n        parts.each { p ->\n            String obj = p\n            if (!obj.startsWith('{')) obj = '{' + obj\n            if (!obj.endsWith('}'))  obj = obj + '}'\n            def dm = (obj =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n            def tm = (obj =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n            if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n        }\n    }\n    out\n}\ndef parseTimeToken = { String token, String meridiemHint ->\n    def IN = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n    String t = token.trim()\n    if (!(t ==~ /(?i).*(AM|PM)$/)) {\n        if (meridiemHint == null) throw new RuntimeException(\"Missing AM/PM for \" + t)\n        t += \" \" + meridiemHint\n    }\n    java.time.LocalTime.parse(t.toUpperCase(), IN)\n}\ndef parseIntervalsForToday = { String timeStr ->\n    String s = normalizeStr(timeStr)\n    if (s.equalsIgnoreCase(\"Closed\")) return []\n    if (s.equalsIgnoreCase(\"Open 24 hours\")) return [[start: java.time.LocalTime.MIN, end: java.time.LocalTime.MAX, eod: true]]\n    def intervals = []\n    for (String part : s.split(\",\")) {\n        String[] bits = part.trim().split(\"-\"); if (bits.length != 2) continue\n        String startRaw = bits[0].trim(), endRaw = bits[1].trim()\n        String endMer = endRaw.toUpperCase().endsWith(\"AM\") ? \"AM\" : endRaw.toUpperCase().endsWith(\"PM\") ? \"PM\" : null\n        try {\n            def end   = parseTimeToken(endRaw, null)\n            def start = parseTimeToken(startRaw, endMer)\n            if (!end.isAfter(start)) {\n                intervals.add([start: start, end: java.time.LocalTime.MAX, eod: true])\n            } else {\n                boolean eod = (end == java.time.LocalTime.MIDNIGHT)\n                intervals.add([start: start, end: (eod ? java.time.LocalTime.MAX : end), eod: eod]);\n            }\n        } catch (ignored) {}\n    }\n    intervals\n}\ndef computeOpenFlagsAndLabel = { List<Map> wdList ->\n    def row = wdList.find { (it.day ?: \"\").equalsIgnoreCase(CURRENT_DAY) }\n    String norm = normalizeStr(row?.time ?: \"\")\n    if (norm.equalsIgnoreCase(\"Open 24 hours\")) return [isOpen:true,  is24x7:true,  t_1:\"Open\",   t_2:\"24/7\"]\n    if (!row || norm.equalsIgnoreCase(\"Closed\")) return [isOpen:false, is24x7:false, t_1:\"Closed\", t_2:\"\"]\n    try {\n        def IN  = java.time.format.DateTimeFormatter.ofPattern(\"h:mm a\")\n        def now = java.time.LocalTime.parse(CURRENT_TIME.toUpperCase(), IN)\n        def active = parseIntervalsForToday(norm).find { iv ->\n            def start = (java.time.LocalTime) iv.start\n            def end   = (java.time.LocalTime) iv.end\n            (now.equals(start) || now.isAfter(start)) && (now.isBefore(end) || now.equals(end))\n        }\n        if (active) {\n            def OUT = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n            boolean eod = (boolean) active.eod\n            def endTime = (java.time.LocalTime) active.end\n            String label = eod ? \"12 AM\" : OUT.format(endTime).replace(\":00 \", \" \")\n            return [isOpen:true, is24x7:false, t_1:\"Open\", t_2:\"Closes \" + label]\n        }\n    } catch (ignored) {}\n    [isOpen:false,is24x7:false, t_1:\"Closed\", t_2:\"\"]\n}\n\n// ---------- Location + Distance ----------\ndef isValidVal = { v -> v != null && !(v.toString().trim().isEmpty()) && !v.toString().equalsIgnoreCase(\"undefined\") && v.toString() != \"-\" }\ndef buildLocation = { Map cols ->\n    def parts = []\n    def city    = getF(cols, ['_pr_City','City'])\n    def govArea = getF(cols, ['_pr_Governarate_Area','Governarate_Area'])\n    def country = getF(cols, ['_pr_Country','Country'])\n    if (isValidVal(city))    parts << city.toString().trim()\n    if (isValidVal(govArea)) parts << govArea.toString().trim()\n    if (isValidVal(country)) parts << country.toString().trim()\n    [location: parts.join(\", \"), location_id: (getF(cols, ['_pr_location_id','location_id']) ?: \"\").toString()]\n}\ndef haversineKm = { double lat1, double lon1, double lat2, double lon2 ->\n    double dLat = Math.toRadians(lat2 - lat1), dLon = Math.toRadians(lon2 - lon1)\n    double a = Math.sin(dLat/2)**2 + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLon/2)**2\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    EARTH_R_KM * c\n}\ndef computeRowDistanceKm = { Map cols ->\n    // include lowercase keys used in your data\n    def lat = toDbl(getF(cols, ['_pr_Latitude','_pr_latitude','latitude','Latitude']))\n    def lon = toDbl(getF(cols, ['_pr_Longitude','_pr_longitude','Longitude','longitude']))\n    if (lat == null || lon == null || ORIGIN_LAT == null || ORIGIN_LON == null) return null\n    haversineKm(ORIGIN_LAT, ORIGIN_LON, lat, lon)\n}\n// formatting rule for distance (one decimal if <10km; else integer)\ndef fmtDistance = { Double d ->\n    if (d == null) return null\n    if (d < 10.0d) {\n        double r = Math.round(d * 10) / 10.0d\n        return (r >= 10.0d) ? (long)Math.round(d) : r\n    }\n    return (long)Math.round(d)\n}\n\n// ---------- Bands & Specialities ----------\ndef normBandTokenLC = { String t ->\n    def x = trimLC(t); if (!x) return null\n    if (x in ['a','band_a','grade_a']) return 'a'\n    if (x in ['a+','a plus','aplus','a_plus']) return 'a+'\n    if (x in ['b','band_b','grade_b']) return 'b'\n    return x\n}\ndef canonBandOut = { String t -> (t == 'a') ? 'A' : (t == 'a+') ? 'A+' : (t == 'b') ? 'B' : t?.toUpperCase() }\ndef extractBandsCanon = { Map cols ->\n    def out = [] as LinkedHashSet\n    def bandVal = getF(cols, ['_pr_Band','Band','band'])\n    parseStringArray(bandVal).each { tok ->\n        def n = normBandTokenLC(tok); if (n) out << canonBandOut(n)\n    }\n    if (cols.A     == true) out << 'A'\n    if (cols.B     == true) out << 'B'\n    if (cols.Aplus == true || cols['A+'] == true || cols.A_plus == true || cols.APlus == true) out << 'A+'\n    out.toList()\n}\ndef extractSpecsLC = { Map cols ->\n    (parseStringArray(getF(cols, ['_pr_Speciality_details','Speciality_details','SpecialityDetails'])) +\n     parseStringArray(getF(cols, ['_pr_Speciality','Speciality'])))\n        .collect { trimLC(it) }\n        .findAll { it }\n        .toSet()\n}\n\n// ---------- Column coercer ----------\ndef coerceColumns = { Map cols ->\n    def out = new LinkedHashMap()\n    cols.each { k, v ->\n        def val = v\n        if (val instanceof CharSequence) {\n            String s = val.toString().trim()\n            if (s.contains('\\\\\\\"')) s = s.replace('\\\\\\\"','\"')\n\n            if (['_pr_weekdayDescriptions','weekdayDescriptions'].contains(k)) {\n                out[k] = toWeekdayList(s); return\n            }\n            if (['_pr_Band','Band','band',\n                  '_pr_Speciality_details','Speciality_details','SpecialityDetails',\n                  '_pr_grants','grants'].contains(k)) {\n                out[k] = parseStringArray(s); return\n            }\n            if (s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"false\") ||\n                s.equalsIgnoreCase(\"yes\")  || s.equalsIgnoreCase(\"no\")) {\n                out[k] = coercePrimitive(s); return\n            }\n            if (s ==~ /^-?\\d+(\\.\\d+)?$/) {\n                out[k] = (s.contains('.') ? Double.parseDouble(s) : Long.parseLong(s)); return\n            }\n            if ((s.startsWith(\"[\") && s.endsWith(\"]\")) || (s.startsWith(\"{\") && s.endsWith(\"}\"))) {\n                out[k] = s.startsWith(\"[\") ? parseArrayGeneric(s) : parseObjectGeneric(s); return\n            }\n            out[k] = s\n        } else {\n            out[k] = val\n        }\n    }\n    return out\n}\n\n// ---------- sort helpers (featured -> distance -> name) ----------\ndef isFeatured = { Map row ->\n    def f = getF(row, ['_pr_FeaturedProvider','FeaturedProvider'])\n    (f instanceof Boolean) ? f : (f?.toString()?.equalsIgnoreCase('true'))\n}\ndef compareRows = { Map a, Map b ->\n    int fa = isFeatured(a) ? 0 : 1\n    int fb = isFeatured(b) ? 0 : 1\n    if (fa != fb) return fa <=> fb\n\n    double da = (a.distance_km instanceof Number) ? ((Number)a.distance_km).doubleValue() : 1.0e15d\n    double db = (b.distance_km instanceof Number) ? ((Number)b.distance_km).doubleValue() : 1.0e15d\n    if (da != db) return da <=> db\n\n    String na = ('' + (getF(a, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    String nb = ('' + (getF(b, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    return na <=> nb\n}\n\n// ---------- Read filter inputs (MODIFIED: Use range_start and range_end instead of distance) ----------\ndef rawOH   = (binding?.hasVariable('openinghrs')) ? openinghrs?.toString()?.trim() : null // \"All\" | \"24/7\" | \"Open Now\"\ndef rawBand = (binding?.hasVariable('band')) ? band : null\ndef rawSpec = (binding?.hasVariable('speciality')) ? speciality : null\n\n// NEW: Get range_start and range_end instead of distance\ndef rawRangeStart = (binding?.hasVariable('range_start')) ? range_start : null\ndef rawRangeEnd = (binding?.hasVariable('range_end')) ? range_end : null\n\ndef wantBands = asList(rawBand).findAll { it != null && it.toString().trim() }\n        .collect { normBandTokenLC(it.toString()) }.findAll { it }.toSet()\ndef wantSpecs = asList(rawSpec).findAll { it != null && it.toString().trim() }\n    .collect { trimLC(it) }.findAll { it }.toSet()\n\n// NEW: Process range inputs to determine distance filtering criteria\ndef rangeStartKm = toDbl(rawRangeStart)\ndef rangeEndKm = toDbl(rawRangeEnd)\n\n// Determine if we should filter by distance range\nboolean hasDistanceFilter = (rangeStartKm != null || rangeEndKm != null)\n\nboolean noOH = (rawOH == null || rawOH == \"\" || rawOH == \"All\")\n\n// ---------- Return-all (no filters) ----------\nif (wantBands.isEmpty() && wantSpecs.isEmpty() && !hasDistanceFilter && noOH) {\n    def allRows = src.collect { row ->\n        def cols = (row.columns instanceof Map) ? row.columns : row\n        def coerced = coerceColumns(cols)\n\n        def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n        def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n        def open = computeOpenFlagsAndLabel(wdList)\n        def dkm = computeRowDistanceKm(coerced)\n        def loc = buildLocation(coerced)\n\n        coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n        coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n        coerced.location = loc.location\n        coerced.location_id = loc.location_id\n        coerced\n    }\n    allRows.sort(compareRows)\n    def totalCount = allRows.size()\n    return [\"countHospitals\": totalCount]\n}\n\n// ---------- AND filter + coerce all (MODIFIED: Use range-based distance filtering) ----------\ndef filtered = src.findAll { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def wdList = toWeekdayList(getF(cols, ['_pr_weekdayDescriptions','weekdayDescriptions']))\n\n    def rowBand = extractBandsCanon(cols).collect { normBandTokenLC(it) }.findAll { it } as Set\n    boolean bandOk = wantBands.isEmpty() || wantBands.every { rowBand.contains(it) }\n\n    def rowSpecs = extractSpecsLC(cols)\n    boolean specOk = wantSpecs.isEmpty() || wantSpecs.every { rowSpecs.contains(it) }\n\n    // NEW: Distance range filtering logic\n    def dkmTmp = computeRowDistanceKm(cols)\n    boolean distOk = true // Default to true if no distance filter\n    \n    if (hasDistanceFilter && dkmTmp != null) {\n        // If only range_start is provided, filter >= range_start\n        if (rangeStartKm != null && rangeEndKm == null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9)\n        }\n        // If only range_end is provided, filter <= range_end\n        else if (rangeStartKm == null && rangeEndKm != null) {\n            distOk = dkmTmp <= (rangeEndKm + 1e-9)\n        }\n        // If both are provided, filter within range [range_start, range_end]\n        else if (rangeStartKm != null && rangeEndKm != null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9) && dkmTmp <= (rangeEndKm + 1e-9)\n        }\n    } else if (hasDistanceFilter && dkmTmp == null) {\n        // If distance filter is requested but we can't calculate distance, exclude the row\n        distOk = false\n    }\n\n    def o = computeOpenFlagsAndLabel(wdList)\n    boolean ohOk = (rawOH == null || rawOH == \"\" || rawOH == \"All\") ? true\n                 : (rawOH == \"24/7\"     ? (o.is24x7 == true)\n                   : rawOH == \"Open Now\" ? (o.isOpen == true)\n                   : true)\n\n    bandOk && specOk && distOk && ohOk\n}.collect { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def coerced = coerceColumns(cols)\n\n    def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n    def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n    def open = computeOpenFlagsAndLabel(wdList)\n    def dkm = computeRowDistanceKm(coerced)\n    def loc = buildLocation(coerced)\n\n    coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n    coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n    coerced.location = loc.location\n    coerced.location_id = loc.location_id\n    coerced\n}\n\nfiltered.sort(compareRows)\ndef totalCount = filtered.size()\nreturn [\"countHospitals\": totalCount]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"data":"{{ _8vNQO.outputs.objects }}",
					"distance":"{{ n_JHETh.outputs.governorte }}",
					"openinghrs":"{{ n_JHETh.outputs.opening_hrs }}",
					"day":"{{ n_JHETh.outputs.day }}",
					"time":"{{ n_JHETh.outputs.time }}",
					"latitude":"{{ n_JHETh.outputs.latitude }}",
					"longitude":"{{ n_JHETh.outputs.longitude }}",
					"range_start":"{{ n_JHETh.outputs.range_start }}",
					"range_end":"{{ n_JHETh.outputs.range_end }}",
					"band":{
						"source":"{{ n_JHETh.outputs.band }}",
						"ua:type":"mappedArray"
					},
					"speciality":{
						"source":"{{ n_JHETh.outputs.speciality }}",
						"ua:type":"mappedArray"
					}
				}
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@1",
			"id":"n_gQ3ri",
			"index":10,
			"inputs":{
				"variables":[
					{
						"source":"{{ n_KSDkd.outputs.total_hospital_records_in_search }}",
						"value":"{{ _LPBQO.outputs.result.countHospitals }}"
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"branch_condition",
				"resourceVersion":0,
				"resourceName":"branch_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@2",
			"id":"n_BxGyJ@2",
			"index":11,
			"inputs":{
				"name":"Branch 2",
				"conditions":{
					"filters":[
						{
							"property":"1",
							"filter":{
								"operator":"EQUAL",
								"value":"1"
							}
						}
					],
					"operator":"AND"
				}
			},
			"skip":false,
			"title":"",
			"type":"BRANCH_CONDITION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				}
			},
			"context":{
				"appName":"analytics_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"analytics_by_unifyapps_execute_query",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@2",
			"id":"_D8Moe",
			"index":12,
			"inputs":{
				"outputSchema":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"total_records"
					],
					"properties":{
						"ProviderID":{
							"type":"string",
							"title":"ProviderID"
						},
						"Speciality":{
							"type":"string",
							"title":"Speciality"
						},
						"Address":{
							"type":"string",
							"title":"Address"
						},
						"medicineDelivery":{
							"type":"string",
							"title":"medicineDelivery"
						},
						"latitude":{
							"type":"number",
							"title":"latitude"
						},
						"FeaturedProvider":{
							"type":"string",
							"title":"FeaturedProvider"
						},
						"SpecialityDetails":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"SpecialityDetails"
						},
						"Band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"City":{
							"type":"string",
							"title":"City"
						},
						"Longitude":{
							"type":"number",
							"title":"Longitude"
						},
						"weekdayDescriptions":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"time":{
										"type":"string",
										"title":"time"
									},
									"day":{
										"type":"string",
										"title":"day"
									}
								},
								"additionalProperties":false
							},
							"title":"weekdayDescriptions"
						},
						"ProviderName":{
							"type":"string",
							"title":"ProviderName"
						},
						"Governarate_Area":{
							"type":"string",
							"title":"Governarate_Area"
						},
						"mapsURL":{
							"type":"string",
							"title":"mapsURL"
						},
						"Country":{
							"type":"string",
							"title":"Country"
						},
						"ContactNumber":{
							"type":"string",
							"title":"ContactNumber"
						},
						"ProviderType":{
							"type":"string",
							"title":"ProviderType"
						},
						"favorite":{
							"type":"string",
							"title":"Favorite"
						},
						"Deleted_fav":{
							"type":"string",
							"title":"Deleted Fav"
						},
						"total_records":{
							"type":"string",
							"title":"Total Records"
						}
					}
				},
				"query":"SELECT\n  np._pr_Longitude, np._pr_Latitude, np._pr_ProviderType, np.id\nFROM ENTITY_oman_network_providers np\nWHERE deleted = false AND\n  LOWER(np._pr_ProviderType) = LOWER('Clinics')\n  AND ('{{ n_JHETh.outputs.city }}' IS NULL OR '{{ n_JHETh.outputs.city }}' = '' OR LOWER(np._pr_City) = LOWER('{{ n_JHETh.outputs.city }}'))\n  AND ('{{ n_JHETh.outputs.Area }}' IS NULL OR '{{ n_JHETh.outputs.Area }}' = '' OR LOWER(np._pr_Governarate_Area) = LOWER('{{ n_JHETh.outputs.Area }}'))\n  AND ('{{ n_JHETh.outputs.Country }}' IS NULL OR '{{ n_JHETh.outputs.Country }}' = '' OR LOWER(np._pr_Country) = LOWER('{{ n_JHETh.outputs.Country }}'))\n  AND ('{{ n_JHETh.outputs.search }}' IS NULL OR '{{ n_JHETh.outputs.search }}' = '' OR LOWER(np._pr_ProviderName) LIKE LOWER('%{{ n_JHETh.outputs.search }}%') OR LOWER(np._pr_Speciality) LIKE LOWER('%{{ n_JHETh.outputs.search }}%'))\n  AND ('{{ n_JHETh.outputs.tab }}' IS NULL OR '{{ n_JHETh.outputs.tab }}' = '' OR LOWER(np._pr_ProviderType) = LOWER('{{ n_JHETh.outputs.tab }}'));\n",
				"group":"ENTITY_REPORTING"
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false,
					"slidingWindowType":"COUNT_BASED"
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"unit":"MINUTES",
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Analytics by UnifyApps",
			"title":"Execute Analytics SQL Query",
			"type":"ACTION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				},
				"visibleOptionalFields":[
					"root.parameters.band.items",
					"root.parameters.speciality.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@2",
			"id":"_1UplZ",
			"index":13,
			"inputs":{
				"output":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"countClinics":{
							"type":"integer",
							"title":"Count Clinics"
						}
					}
				},
				"input":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"data":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Data"
						},
						"speciality":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Speciality"
						},
						"distance":{
							"type":"string",
							"title":"Distance"
						},
						"openinghrs":{
							"type":"string",
							"title":"openinghrs"
						},
						"day":{
							"type":"string",
							"title":"Day"
						},
						"time":{
							"type":"string",
							"title":"Time"
						},
						"latitude":{
							"type":"string",
							"title":"Latitude"
						},
						"longitude":{
							"type":"string",
							"title":"Longitude"
						},
						"range_start":{
							"type":"string",
							"title":"Range Start"
						},
						"range_end":{
							"type":"string",
							"title":"Range End"
						}
					}
				},
				"code":"// ---------- Early exit for SQL \"no rows\" ----------\ndef d0 = (binding?.hasVariable('data')) ? data : null\nif (d0 instanceof Map && d0.size() == 1 && d0.containsKey('hasMore')) {\n    return d0 // {\"result\":{\"hasMore\":false}}\n}\n\n// ---------- Load rows ----------\ndef src = (d0 instanceof Collection) ? d0 as List\n         : (d0 instanceof Map       ) ? [d0]\n         : []\nif (src.isEmpty()) return []\n\n// ---------- Constants ----------\nfinal double EARTH_R_KM = 6371.0088d\n\n// ---------- Get current Oman time ----------\nimport java.time.*\nimport java.time.format.*\n\ndef omanZone = ZoneId.of(\"Asia/Muscat\")\ndef omanNow = ZonedDateTime.now(omanZone)\nfinal String CURRENT_DAY = omanNow.getDayOfWeek().getDisplayName(java.time.format.TextStyle.FULL, Locale.ENGLISH)\nfinal String CURRENT_TIME = omanNow.format(DateTimeFormatter.ofPattern(\"h:mm a\"))\n\n// ---------- Small helpers ----------\ndef asList  = { v -> (v == null) ? [] : (v instanceof Collection ? v as List : [v]) }\ndef trimLC  = { s -> s?.toString()?.trim()?.toLowerCase() }\ndef toDbl   = { v ->\n    if (v == null) return null\n    if (v instanceof Number) return ((Number)v).doubleValue()\n    def s = v.toString().trim()\n    if (!s || s.equalsIgnoreCase('null') || s.equalsIgnoreCase('na')) return null\n    try { return Double.parseDouble(s) } catch (ignored) { return null }\n}\ndef getF = { Map m, List keys -> for (k in keys) { if (m.containsKey(k) && m[k] != null) return m[k] }; return null }\n\n// ---------- Use input origin (latitude/longitude) WITHOUT fallback ----------\ndef ORIGIN_LAT = toDbl(binding?.hasVariable('latitude') ? latitude : -1)\ndef ORIGIN_LON = toDbl(binding?.hasVariable('longitude') ? longitude : -1)\n\n// ---------- Normalize / JSON-ish parsing (no JsonSlurper) ----------\ndef normalizeStr = { String s ->\n    if (s == null) return \"\"\n    s.replaceAll(\"[\\u2013\\u2014\\u2212]\", \"-\")\n     .replaceAll(\"[\\u2009\\u202F\\u00A0]\", \" \")\n     .replaceAll(\"\\\\s*,\\\\s*\", \",\")\n     .replaceAll(\"\\\\s*-\\\\s*\", \"-\")\n     .replaceAll(\"\\\\s+\", \" \")\n     .trim()\n}\ndef coercePrimitive = { String t ->\n    if (t == null) return null\n    def x = t.trim()\n    if (!x) return \"\"\n    if ((x.startsWith('\"') && x.endsWith('\"')) || (x.startsWith(\"'\") && x.endsWith(\"'\"))) {\n        x = x.substring(1, x.length()-1)\n    }\n    if (x.equalsIgnoreCase(\"true\"))  return true\n    if (x.equalsIgnoreCase(\"false\")) return false\n    if (x.equalsIgnoreCase(\"yes\"))   return true\n    if (x.equalsIgnoreCase(\"no\"))    return false\n    if (x ==~ /^-?\\d+$/)             return Long.parseLong(x)\n    if (x ==~ /^-?\\d+\\.\\d+$/)        return Double.parseDouble(x)\n    return x\n}\ndef parseArrayGeneric = { String arr ->\n    String s = arr?.trim() ?: \"\"\n    if (!s.startsWith(\"[\") || !s.endsWith(\"]\")) return s\n\n    if (s.contains(\"{\")) {\n        def blocks = (s =~ /\\{[^}]*\\}/)\n        def out = []\n        blocks.each { m -> out << parseObjectGeneric(m[0]) }\n        if (!out.isEmpty()) return out\n    }\n\n    def tokens = []\n    def qt = (s =~ /\"(.*?)\"|'(.*?)'/)\n    qt.each { _, g1, g2 -> tokens << (g1 ?: g2) }\n    if (!tokens.isEmpty()) return tokens.collect { coercePrimitive(it) }\n\n    def inner = s.substring(1, s.length()-1)\n    return inner.split(/\\s*,\\s*/).findAll { it != null && it.trim() }.collect { coercePrimitive(it) }\n}\ndef parseObjectGeneric = { String obj ->\n    String o = obj?.trim() ?: \"\"\n    if (!o.startsWith(\"{\") || !o.endsWith(\"}\")) return o\n    def map = [:]\n\n    def arrRe = (o =~ /\"([^\"]+)\"\\s*:\\s*(\\[[^\\]]*\\])/)\n    arrRe.each { m -> map[m[1]] = parseArrayGeneric(m[2]) }\n\n    def strRe = (o =~ /\"([^\"]+)\"\\s*:\\s*\"([^\"]*)\"/)\n    strRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2] }\n\n    def numRe = (o =~ /\"([^\"]+)\"\\s*:\\s*([-]?\\d+(?:\\.\\d+)?)/)\n    numRe.each { m ->\n        if (!map.containsKey(m[1])) map[m[1]] = (m[2].contains('.') ? Double.parseDouble(m[2]) : Long.parseLong(m[2]))\n    }\n\n    def boolRe = (o =~ /\"([^\"]+)\"\\s*:\\s*((?i:true|false))/)\n    boolRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2].equalsIgnoreCase(\"true\") }\n\n    return map\n}\ndef parseStringArray = { v ->\n    if (v == null) return []\n    if (v instanceof Collection) return v.collect { it?.toString() }\n    def s = v.toString().trim(); if (!s) return []\n    if ((s.startsWith('[') && s.endsWith(']')) || (s.startsWith('(') && s.endsWith(')'))) {\n        def u = s.contains('\\\\\\\"') ? s.replace('\\\\\\\"','\"') : s\n        def toks = []\n        def m = (u =~ /\"(.*?)\"|'(.*?)'/)\n        m.each { _, g1, g2 -> def tok = (g1 ?: g2); if (tok != null && tok.trim()) toks << tok }\n        if (toks.isEmpty()) {\n            def inner = u.substring(1, u.length()-1)\n            toks = inner.split(/\\s*,\\s*|\\s*\\|\\s*/)\n        }\n        return toks.collect { it?.toString() }\n    }\n    return s.split(/\\s*,\\s*|\\s*\\|\\s*/).collect { it?.toString() }\n}\n\n// ---------- Hours ----------\ndef toWeekdayList = { Object wd ->\n    if (wd == null) return []\n    if (wd instanceof Collection) {\n        return wd.collect { it instanceof Map ? [day: it.day?.toString(), time: it.time?.toString()] : it }\n    }\n    String u = wd.toString().trim()\n    if (!u) return []\n    if (u.contains('\\\\\\\"')) u = u.replace('\\\\\\\"','\"')\n    def blocks = (u =~ /\\{[^}]*\\}/)\n    def out = []\n    blocks.each { m ->\n        String ob = m[0]\n        def dm = (ob =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n        def tm = (ob =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n        if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n    }\n    if (out.isEmpty() && u.startsWith('[') && u.endsWith(']')) {\n        def parts = u.substring(1, u.length()-1).split(/}\\s*,\\s*\\{/)\n        parts.each { p ->\n            String obj = p\n            if (!obj.startsWith('{')) obj = '{' + obj\n            if (!obj.endsWith('}'))  obj = obj + '}'\n            def dm = (obj =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n            def tm = (obj =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n            if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n        }\n    }\n    out\n}\ndef parseTimeToken = { String token, String meridiemHint ->\n    def IN = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n    String t = token.trim()\n    if (!(t ==~ /(?i).*(AM|PM)$/)) {\n        if (meridiemHint == null) throw new RuntimeException(\"Missing AM/PM for \" + t)\n        t += \" \" + meridiemHint\n    }\n    java.time.LocalTime.parse(t.toUpperCase(), IN)\n}\ndef parseIntervalsForToday = { String timeStr ->\n    String s = normalizeStr(timeStr)\n    if (s.equalsIgnoreCase(\"Closed\")) return []\n    if (s.equalsIgnoreCase(\"Open 24 hours\")) return [[start: java.time.LocalTime.MIN, end: java.time.LocalTime.MAX, eod: true]]\n    def intervals = []\n    for (String part : s.split(\",\")) {\n        String[] bits = part.trim().split(\"-\"); if (bits.length != 2) continue\n        String startRaw = bits[0].trim(), endRaw = bits[1].trim()\n        String endMer = endRaw.toUpperCase().endsWith(\"AM\") ? \"AM\" : endRaw.toUpperCase().endsWith(\"PM\") ? \"PM\" : null\n        try {\n            def end   = parseTimeToken(endRaw, null)\n            def start = parseTimeToken(startRaw, endMer)\n            if (!end.isAfter(start)) {\n                intervals.add([start: start, end: java.time.LocalTime.MAX, eod: true])\n            } else {\n                boolean eod = (end == java.time.LocalTime.MIDNIGHT)\n                intervals.add([start: start, end: (eod ? java.time.LocalTime.MAX : end), eod: eod]);\n            }\n        } catch (ignored) {}\n    }\n    intervals\n}\ndef computeOpenFlagsAndLabel = { List<Map> wdList ->\n    def row = wdList.find { (it.day ?: \"\").equalsIgnoreCase(CURRENT_DAY) }\n    String norm = normalizeStr(row?.time ?: \"\")\n    if (norm.equalsIgnoreCase(\"Open 24 hours\")) return [isOpen:true,  is24x7:true,  t_1:\"Open\",   t_2:\"24/7\"]\n    if (!row || norm.equalsIgnoreCase(\"Closed\")) return [isOpen:false, is24x7:false, t_1:\"Closed\", t_2:\"\"]\n    try {\n        def IN  = java.time.format.DateTimeFormatter.ofPattern(\"h:mm a\")\n        def now = java.time.LocalTime.parse(CURRENT_TIME.toUpperCase(), IN)\n        def active = parseIntervalsForToday(norm).find { iv ->\n            def start = (java.time.LocalTime) iv.start\n            def end   = (java.time.LocalTime) iv.end\n            (now.equals(start) || now.isAfter(start)) && (now.isBefore(end) || now.equals(end))\n        }\n        if (active) {\n            def OUT = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n            boolean eod = (boolean) active.eod\n            def endTime = (java.time.LocalTime) active.end\n            String label = eod ? \"12 AM\" : OUT.format(endTime).replace(\":00 \", \" \")\n            return [isOpen:true, is24x7:false, t_1:\"Open\", t_2:\"Closes \" + label]\n        }\n    } catch (ignored) {}\n    [isOpen:false,is24x7:false, t_1:\"Closed\", t_2:\"\"]\n}\n\n// ---------- Location + Distance ----------\ndef isValidVal = { v -> v != null && !(v.toString().trim().isEmpty()) && !v.toString().equalsIgnoreCase(\"undefined\") && v.toString() != \"-\" }\ndef buildLocation = { Map cols ->\n    def parts = []\n    def city    = getF(cols, ['_pr_City','City'])\n    def govArea = getF(cols, ['_pr_Governarate_Area','Governarate_Area'])\n    def country = getF(cols, ['_pr_Country','Country'])\n    if (isValidVal(city))    parts << city.toString().trim()\n    if (isValidVal(govArea)) parts << govArea.toString().trim()\n    if (isValidVal(country)) parts << country.toString().trim()\n    [location: parts.join(\", \"), location_id: (getF(cols, ['_pr_location_id','location_id']) ?: \"\").toString()]\n}\ndef haversineKm = { double lat1, double lon1, double lat2, double lon2 ->\n    double dLat = Math.toRadians(lat2 - lat1), dLon = Math.toRadians(lon2 - lon1)\n    double a = Math.sin(dLat/2)**2 + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLon/2)**2\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    EARTH_R_KM * c\n}\ndef computeRowDistanceKm = { Map cols ->\n    // include lowercase keys used in your data\n    def lat = toDbl(getF(cols, ['_pr_Latitude','_pr_latitude','latitude','Latitude']))\n    def lon = toDbl(getF(cols, ['_pr_Longitude','_pr_longitude','Longitude','longitude']))\n    if (lat == null || lon == null || ORIGIN_LAT == null || ORIGIN_LON == null) return null\n    haversineKm(ORIGIN_LAT, ORIGIN_LON, lat, lon)\n}\n// formatting rule for distance (one decimal if <10km; else integer)\ndef fmtDistance = { Double d ->\n    if (d == null) return null\n    if (d < 10.0d) {\n        double r = Math.round(d * 10) / 10.0d\n        return (r >= 10.0d) ? (long)Math.round(d) : r\n    }\n    return (long)Math.round(d)\n}\n\n// ---------- Bands & Specialities ----------\ndef normBandTokenLC = { String t ->\n    def x = trimLC(t); if (!x) return null\n    if (x in ['a','band_a','grade_a']) return 'a'\n    if (x in ['a+','a plus','aplus','a_plus']) return 'a+'\n    if (x in ['b','band_b','grade_b']) return 'b'\n    return x\n}\ndef canonBandOut = { String t -> (t == 'a') ? 'A' : (t == 'a+') ? 'A+' : (t == 'b') ? 'B' : t?.toUpperCase() }\ndef extractBandsCanon = { Map cols ->\n    def out = [] as LinkedHashSet\n    def bandVal = getF(cols, ['_pr_Band','Band','band'])\n    parseStringArray(bandVal).each { tok ->\n        def n = normBandTokenLC(tok); if (n) out << canonBandOut(n)\n    }\n    if (cols.A     == true) out << 'A'\n    if (cols.B     == true) out << 'B'\n    if (cols.Aplus == true || cols['A+'] == true || cols.A_plus == true || cols.APlus == true) out << 'A+'\n    out.toList()\n}\ndef extractSpecsLC = { Map cols ->\n    (parseStringArray(getF(cols, ['_pr_Speciality_details','Speciality_details','SpecialityDetails'])) +\n     parseStringArray(getF(cols, ['_pr_Speciality','Speciality'])))\n        .collect { trimLC(it) }\n        .findAll { it }\n        .toSet()\n}\n\n// ---------- Column coercer ----------\ndef coerceColumns = { Map cols ->\n    def out = new LinkedHashMap()\n    cols.each { k, v ->\n        def val = v\n        if (val instanceof CharSequence) {\n            String s = val.toString().trim()\n            if (s.contains('\\\\\\\"')) s = s.replace('\\\\\\\"','\"')\n\n            if (['_pr_weekdayDescriptions','weekdayDescriptions'].contains(k)) {\n                out[k] = toWeekdayList(s); return\n            }\n            if (['_pr_Band','Band','band',\n                  '_pr_Speciality_details','Speciality_details','SpecialityDetails',\n                  '_pr_grants','grants'].contains(k)) {\n                out[k] = parseStringArray(s); return\n            }\n            if (s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"false\") ||\n                s.equalsIgnoreCase(\"yes\")  || s.equalsIgnoreCase(\"no\")) {\n                out[k] = coercePrimitive(s); return\n            }\n            if (s ==~ /^-?\\d+(\\.\\d+)?$/) {\n                out[k] = (s.contains('.') ? Double.parseDouble(s) : Long.parseLong(s)); return\n            }\n            if ((s.startsWith(\"[\") && s.endsWith(\"]\")) || (s.startsWith(\"{\") && s.endsWith(\"}\"))) {\n                out[k] = s.startsWith(\"[\") ? parseArrayGeneric(s) : parseObjectGeneric(s); return\n            }\n            out[k] = s\n        } else {\n            out[k] = val\n        }\n    }\n    return out\n}\n\n// ---------- sort helpers (featured -> distance -> name) ----------\ndef isFeatured = { Map row ->\n    def f = getF(row, ['_pr_FeaturedProvider','FeaturedProvider'])\n    (f instanceof Boolean) ? f : (f?.toString()?.equalsIgnoreCase('true'))\n}\ndef compareRows = { Map a, Map b ->\n    int fa = isFeatured(a) ? 0 : 1\n    int fb = isFeatured(b) ? 0 : 1\n    if (fa != fb) return fa <=> fb\n\n    double da = (a.distance_km instanceof Number) ? ((Number)a.distance_km).doubleValue() : 1.0e15d\n    double db = (b.distance_km instanceof Number) ? ((Number)b.distance_km).doubleValue() : 1.0e15d\n    if (da != db) return da <=> db\n\n    String na = ('' + (getF(a, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    String nb = ('' + (getF(b, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    return na <=> nb\n}\n\n// ---------- Read filter inputs (MODIFIED: Use range_start and range_end instead of distance) ----------\ndef rawOH   = (binding?.hasVariable('openinghrs')) ? openinghrs?.toString()?.trim() : null // \"All\" | \"24/7\" | \"Open Now\"\ndef rawBand = (binding?.hasVariable('band')) ? band : null\ndef rawSpec = (binding?.hasVariable('speciality')) ? speciality : null\n\n// NEW: Get range_start and range_end instead of distance\ndef rawRangeStart = (binding?.hasVariable('range_start')) ? range_start : null\ndef rawRangeEnd = (binding?.hasVariable('range_end')) ? range_end : null\n\ndef wantBands = asList(rawBand).findAll { it != null && it.toString().trim() }\n        .collect { normBandTokenLC(it.toString()) }.findAll { it }.toSet()\ndef wantSpecs = asList(rawSpec).findAll { it != null && it.toString().trim() }\n    .collect { trimLC(it) }.findAll { it }.toSet()\n\n// NEW: Process range inputs to determine distance filtering criteria\ndef rangeStartKm = toDbl(rawRangeStart)\ndef rangeEndKm = toDbl(rawRangeEnd)\n\n// Determine if we should filter by distance range\nboolean hasDistanceFilter = (rangeStartKm != null || rangeEndKm != null)\n\nboolean noOH = (rawOH == null || rawOH == \"\" || rawOH == \"All\")\n\n// ---------- Return-all (no filters) ----------\nif (wantBands.isEmpty() && wantSpecs.isEmpty() && !hasDistanceFilter && noOH) {\n    def allRows = src.collect { row ->\n        def cols = (row.columns instanceof Map) ? row.columns : row\n        def coerced = coerceColumns(cols)\n\n        def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n        def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n        def open = computeOpenFlagsAndLabel(wdList)\n        def dkm = computeRowDistanceKm(coerced)\n        def loc = buildLocation(coerced)\n\n        coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n        coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n        coerced.location = loc.location\n        coerced.location_id = loc.location_id\n        coerced\n    }\n    allRows.sort(compareRows)\n    def totalCount = allRows.size()\n    return [\"countHospitals\": totalCount]\n}\n\n// ---------- AND filter + coerce all (MODIFIED: Use range-based distance filtering) ----------\ndef filtered = src.findAll { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def wdList = toWeekdayList(getF(cols, ['_pr_weekdayDescriptions','weekdayDescriptions']))\n\n    def rowBand = extractBandsCanon(cols).collect { normBandTokenLC(it) }.findAll { it } as Set\n    boolean bandOk = wantBands.isEmpty() || wantBands.every { rowBand.contains(it) }\n\n    def rowSpecs = extractSpecsLC(cols)\n    boolean specOk = wantSpecs.isEmpty() || wantSpecs.every { rowSpecs.contains(it) }\n\n    // NEW: Distance range filtering logic\n    def dkmTmp = computeRowDistanceKm(cols)\n    boolean distOk = true // Default to true if no distance filter\n    \n    if (hasDistanceFilter && dkmTmp != null) {\n        // If only range_start is provided, filter >= range_start\n        if (rangeStartKm != null && rangeEndKm == null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9)\n        }\n        // If only range_end is provided, filter <= range_end\n        else if (rangeStartKm == null && rangeEndKm != null) {\n            distOk = dkmTmp <= (rangeEndKm + 1e-9)\n        }\n        // If both are provided, filter within range [range_start, range_end]\n        else if (rangeStartKm != null && rangeEndKm != null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9) && dkmTmp <= (rangeEndKm + 1e-9)\n        }\n    } else if (hasDistanceFilter && dkmTmp == null) {\n        // If distance filter is requested but we can't calculate distance, exclude the row\n        distOk = false\n    }\n\n    def o = computeOpenFlagsAndLabel(wdList)\n    boolean ohOk = (rawOH == null || rawOH == \"\" || rawOH == \"All\") ? true\n                 : (rawOH == \"24/7\"     ? (o.is24x7 == true)\n                   : rawOH == \"Open Now\" ? (o.isOpen == true)\n                   : true)\n\n    bandOk && specOk && distOk && ohOk\n}.collect { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def coerced = coerceColumns(cols)\n\n    def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n    def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n    def open = computeOpenFlagsAndLabel(wdList)\n    def dkm = computeRowDistanceKm(coerced)\n    def loc = buildLocation(coerced)\n\n    coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n    coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n    coerced.location = loc.location\n    coerced.location_id = loc.location_id\n    coerced\n}\n\nfiltered.sort(compareRows)\ndef totalCount = filtered.size()\nreturn [\"countClinics\": totalCount]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"data":"{{ _D8Moe.outputs.objects }}",
					"distance":"{{ n_JHETh.outputs.governorte }}",
					"openinghrs":"{{ n_JHETh.outputs.opening_hrs }}",
					"day":"{{ n_JHETh.outputs.day }}",
					"time":"{{ n_JHETh.outputs.time }}",
					"latitude":"{{ n_JHETh.outputs.latitude }}",
					"longitude":"{{ n_JHETh.outputs.longitude }}",
					"range_start":"{{ n_JHETh.outputs.range_start }}",
					"range_end":"{{ n_JHETh.outputs.range_end }}",
					"band":{
						"source":"{{ n_JHETh.outputs.band }}",
						"ua:type":"mappedArray"
					},
					"speciality":{
						"source":"{{ n_JHETh.outputs.speciality }}",
						"ua:type":"mappedArray"
					}
				}
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@2",
			"id":"_MyKIq",
			"index":14,
			"inputs":{
				"variables":[
					{
						"source":"{{ _4Jeol.outputs.total_clinics_records_in_search }}",
						"value":"{{ _1UplZ.outputs.result.countClinics }}"
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"branch_condition",
				"resourceVersion":0,
				"resourceName":"branch_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@3",
			"id":"n_BxGyJ@3",
			"index":15,
			"inputs":{
				"name":"Branch 3",
				"conditions":{
					"filters":[
						{
							"property":"1",
							"filter":{
								"operator":"EQUAL",
								"value":"1"
							}
						}
					],
					"operator":"AND"
				}
			},
			"skip":false,
			"title":"",
			"type":"BRANCH_CONDITION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				}
			},
			"context":{
				"appName":"analytics_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"analytics_by_unifyapps_execute_query",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@3",
			"id":"_sdiv9",
			"index":16,
			"inputs":{
				"outputSchema":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"total_records"
					],
					"properties":{
						"ProviderID":{
							"type":"string",
							"title":"ProviderID"
						},
						"Speciality":{
							"type":"string",
							"title":"Speciality"
						},
						"Address":{
							"type":"string",
							"title":"Address"
						},
						"medicineDelivery":{
							"type":"string",
							"title":"medicineDelivery"
						},
						"latitude":{
							"type":"number",
							"title":"latitude"
						},
						"FeaturedProvider":{
							"type":"string",
							"title":"FeaturedProvider"
						},
						"SpecialityDetails":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"SpecialityDetails"
						},
						"Band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"City":{
							"type":"string",
							"title":"City"
						},
						"Longitude":{
							"type":"number",
							"title":"Longitude"
						},
						"weekdayDescriptions":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"time":{
										"type":"string",
										"title":"time"
									},
									"day":{
										"type":"string",
										"title":"day"
									}
								},
								"additionalProperties":false
							},
							"title":"weekdayDescriptions"
						},
						"ProviderName":{
							"type":"string",
							"title":"ProviderName"
						},
						"Governarate_Area":{
							"type":"string",
							"title":"Governarate_Area"
						},
						"mapsURL":{
							"type":"string",
							"title":"mapsURL"
						},
						"Country":{
							"type":"string",
							"title":"Country"
						},
						"ContactNumber":{
							"type":"string",
							"title":"ContactNumber"
						},
						"ProviderType":{
							"type":"string",
							"title":"ProviderType"
						},
						"favorite":{
							"type":"string",
							"title":"Favorite"
						},
						"Deleted_fav":{
							"type":"string",
							"title":"Deleted Fav"
						},
						"total_records":{
							"type":"string",
							"title":"Total Records"
						}
					}
				},
				"query":"SELECT\n  np._pr_Longitude, np._pr_Latitude, np._pr_ProviderType, np.id\nFROM ENTITY_oman_network_providers np\nWHERE deleted = false AND\n  LOWER(np._pr_ProviderType) = LOWER('Pharmacy')\n  AND ('{{ n_JHETh.outputs.city }}' IS NULL OR '{{ n_JHETh.outputs.city }}' = '' OR LOWER(np._pr_City) = LOWER('{{ n_JHETh.outputs.city }}'))\n  AND ('{{ n_JHETh.outputs.Area }}' IS NULL OR '{{ n_JHETh.outputs.Area }}' = '' OR LOWER(np._pr_Governarate_Area) = LOWER('{{ n_JHETh.outputs.Area }}'))\n  AND ('{{ n_JHETh.outputs.Country }}' IS NULL OR '{{ n_JHETh.outputs.Country }}' = '' OR LOWER(np._pr_Country) = LOWER('{{ n_JHETh.outputs.Country }}'))\n  AND ('{{ n_JHETh.outputs.search }}' IS NULL OR '{{ n_JHETh.outputs.search }}' = '' OR LOWER(np._pr_ProviderName) LIKE LOWER('%{{ n_JHETh.outputs.search }}%') OR LOWER(np._pr_Speciality) LIKE LOWER('%{{ n_JHETh.outputs.search }}%'))\n  AND ('{{ n_JHETh.outputs.tab }}' IS NULL OR '{{ n_JHETh.outputs.tab }}' = '' OR LOWER(np._pr_ProviderType) = LOWER('{{ n_JHETh.outputs.tab }}'));\n",
				"group":"ENTITY_REPORTING"
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false,
					"slidingWindowType":"COUNT_BASED"
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"unit":"MINUTES",
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Analytics by UnifyApps",
			"title":"Execute Analytics SQL Query",
			"type":"ACTION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				},
				"visibleOptionalFields":[
					"root.parameters.band.items",
					"root.parameters.speciality.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@3",
			"id":"_LjaEI",
			"index":17,
			"inputs":{
				"output":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"countPharmacy"
					],
					"properties":{
						"countPharmacy":{
							"type":"integer",
							"title":"Count Pharmacy"
						}
					}
				},
				"input":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"data":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Data"
						},
						"speciality":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Speciality"
						},
						"distance":{
							"type":"string",
							"title":"Distance"
						},
						"openinghrs":{
							"type":"string",
							"title":"openinghrs"
						},
						"day":{
							"type":"string",
							"title":"Day"
						},
						"time":{
							"type":"string",
							"title":"Time"
						},
						"latitude":{
							"type":"string",
							"title":"Latitude"
						},
						"longitude":{
							"type":"string",
							"title":"Longitude"
						},
						"range_start":{
							"type":"string",
							"title":"Range Start"
						},
						"range_end":{
							"type":"string",
							"title":"Range End"
						}
					}
				},
				"code":"// ---------- Early exit for SQL \"no rows\" ----------\ndef d0 = (binding?.hasVariable('data')) ? data : null\nif (d0 instanceof Map && d0.size() == 1 && d0.containsKey('hasMore')) {\n    return d0 // {\"result\":{\"hasMore\":false}}\n}\n\n// ---------- Load rows ----------\ndef src = (d0 instanceof Collection) ? d0 as List\n         : (d0 instanceof Map       ) ? [d0]\n         : []\nif (src.isEmpty()) return []\n\n// ---------- Constants ----------\nfinal double EARTH_R_KM = 6371.0088d\n\n// ---------- Get current Oman time ----------\nimport java.time.*\nimport java.time.format.*\n\ndef omanZone = ZoneId.of(\"Asia/Muscat\")\ndef omanNow = ZonedDateTime.now(omanZone)\nfinal String CURRENT_DAY = omanNow.getDayOfWeek().getDisplayName(java.time.format.TextStyle.FULL, Locale.ENGLISH)\nfinal String CURRENT_TIME = omanNow.format(DateTimeFormatter.ofPattern(\"h:mm a\"))\n\n// ---------- Small helpers ----------\ndef asList  = { v -> (v == null) ? [] : (v instanceof Collection ? v as List : [v]) }\ndef trimLC  = { s -> s?.toString()?.trim()?.toLowerCase() }\ndef toDbl   = { v ->\n    if (v == null) return null\n    if (v instanceof Number) return ((Number)v).doubleValue()\n    def s = v.toString().trim()\n    if (!s || s.equalsIgnoreCase('null') || s.equalsIgnoreCase('na')) return null\n    try { return Double.parseDouble(s) } catch (ignored) { return null }\n}\ndef getF = { Map m, List keys -> for (k in keys) { if (m.containsKey(k) && m[k] != null) return m[k] }; return null }\n\n// ---------- Use input origin (latitude/longitude) WITHOUT fallback ----------\ndef ORIGIN_LAT = toDbl(binding?.hasVariable('latitude') ? latitude : -1)\ndef ORIGIN_LON = toDbl(binding?.hasVariable('longitude') ? longitude : -1)\n\n// ---------- Normalize / JSON-ish parsing (no JsonSlurper) ----------\ndef normalizeStr = { String s ->\n    if (s == null) return \"\"\n    s.replaceAll(\"[\\u2013\\u2014\\u2212]\", \"-\")\n     .replaceAll(\"[\\u2009\\u202F\\u00A0]\", \" \")\n     .replaceAll(\"\\\\s*,\\\\s*\", \",\")\n     .replaceAll(\"\\\\s*-\\\\s*\", \"-\")\n     .replaceAll(\"\\\\s+\", \" \")\n     .trim()\n}\ndef coercePrimitive = { String t ->\n    if (t == null) return null\n    def x = t.trim()\n    if (!x) return \"\"\n    if ((x.startsWith('\"') && x.endsWith('\"')) || (x.startsWith(\"'\") && x.endsWith(\"'\"))) {\n        x = x.substring(1, x.length()-1)\n    }\n    if (x.equalsIgnoreCase(\"true\"))  return true\n    if (x.equalsIgnoreCase(\"false\")) return false\n    if (x.equalsIgnoreCase(\"yes\"))   return true\n    if (x.equalsIgnoreCase(\"no\"))    return false\n    if (x ==~ /^-?\\d+$/)             return Long.parseLong(x)\n    if (x ==~ /^-?\\d+\\.\\d+$/)        return Double.parseDouble(x)\n    return x\n}\ndef parseArrayGeneric = { String arr ->\n    String s = arr?.trim() ?: \"\"\n    if (!s.startsWith(\"[\") || !s.endsWith(\"]\")) return s\n\n    if (s.contains(\"{\")) {\n        def blocks = (s =~ /\\{[^}]*\\}/)\n        def out = []\n        blocks.each { m -> out << parseObjectGeneric(m[0]) }\n        if (!out.isEmpty()) return out\n    }\n\n    def tokens = []\n    def qt = (s =~ /\"(.*?)\"|'(.*?)'/)\n    qt.each { _, g1, g2 -> tokens << (g1 ?: g2) }\n    if (!tokens.isEmpty()) return tokens.collect { coercePrimitive(it) }\n\n    def inner = s.substring(1, s.length()-1)\n    return inner.split(/\\s*,\\s*/).findAll { it != null && it.trim() }.collect { coercePrimitive(it) }\n}\ndef parseObjectGeneric = { String obj ->\n    String o = obj?.trim() ?: \"\"\n    if (!o.startsWith(\"{\") || !o.endsWith(\"}\")) return o\n    def map = [:]\n\n    def arrRe = (o =~ /\"([^\"]+)\"\\s*:\\s*(\\[[^\\]]*\\])/)\n    arrRe.each { m -> map[m[1]] = parseArrayGeneric(m[2]) }\n\n    def strRe = (o =~ /\"([^\"]+)\"\\s*:\\s*\"([^\"]*)\"/)\n    strRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2] }\n\n    def numRe = (o =~ /\"([^\"]+)\"\\s*:\\s*([-]?\\d+(?:\\.\\d+)?)/)\n    numRe.each { m ->\n        if (!map.containsKey(m[1])) map[m[1]] = (m[2].contains('.') ? Double.parseDouble(m[2]) : Long.parseLong(m[2]))\n    }\n\n    def boolRe = (o =~ /\"([^\"]+)\"\\s*:\\s*((?i:true|false))/)\n    boolRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2].equalsIgnoreCase(\"true\") }\n\n    return map\n}\ndef parseStringArray = { v ->\n    if (v == null) return []\n    if (v instanceof Collection) return v.collect { it?.toString() }\n    def s = v.toString().trim(); if (!s) return []\n    if ((s.startsWith('[') && s.endsWith(']')) || (s.startsWith('(') && s.endsWith(')'))) {\n        def u = s.contains('\\\\\\\"') ? s.replace('\\\\\\\"','\"') : s\n        def toks = []\n        def m = (u =~ /\"(.*?)\"|'(.*?)'/)\n        m.each { _, g1, g2 -> def tok = (g1 ?: g2); if (tok != null && tok.trim()) toks << tok }\n        if (toks.isEmpty()) {\n            def inner = u.substring(1, u.length()-1)\n            toks = inner.split(/\\s*,\\s*|\\s*\\|\\s*/)\n        }\n        return toks.collect { it?.toString() }\n    }\n    return s.split(/\\s*,\\s*|\\s*\\|\\s*/).collect { it?.toString() }\n}\n\n// ---------- Hours ----------\ndef toWeekdayList = { Object wd ->\n    if (wd == null) return []\n    if (wd instanceof Collection) {\n        return wd.collect { it instanceof Map ? [day: it.day?.toString(), time: it.time?.toString()] : it }\n    }\n    String u = wd.toString().trim()\n    if (!u) return []\n    if (u.contains('\\\\\\\"')) u = u.replace('\\\\\\\"','\"')\n    def blocks = (u =~ /\\{[^}]*\\}/)\n    def out = []\n    blocks.each { m ->\n        String ob = m[0]\n        def dm = (ob =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n        def tm = (ob =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n        if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n    }\n    if (out.isEmpty() && u.startsWith('[') && u.endsWith(']')) {\n        def parts = u.substring(1, u.length()-1).split(/}\\s*,\\s*\\{/)\n        parts.each { p ->\n            String obj = p\n            if (!obj.startsWith('{')) obj = '{' + obj\n            if (!obj.endsWith('}'))  obj = obj + '}'\n            def dm = (obj =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n            def tm = (obj =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n            if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n        }\n    }\n    out\n}\ndef parseTimeToken = { String token, String meridiemHint ->\n    def IN = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n    String t = token.trim()\n    if (!(t ==~ /(?i).*(AM|PM)$/)) {\n        if (meridiemHint == null) throw new RuntimeException(\"Missing AM/PM for \" + t)\n        t += \" \" + meridiemHint\n    }\n    java.time.LocalTime.parse(t.toUpperCase(), IN)\n}\ndef parseIntervalsForToday = { String timeStr ->\n    String s = normalizeStr(timeStr)\n    if (s.equalsIgnoreCase(\"Closed\")) return []\n    if (s.equalsIgnoreCase(\"Open 24 hours\")) return [[start: java.time.LocalTime.MIN, end: java.time.LocalTime.MAX, eod: true]]\n    def intervals = []\n    for (String part : s.split(\",\")) {\n        String[] bits = part.trim().split(\"-\"); if (bits.length != 2) continue\n        String startRaw = bits[0].trim(), endRaw = bits[1].trim()\n        String endMer = endRaw.toUpperCase().endsWith(\"AM\") ? \"AM\" : endRaw.toUpperCase().endsWith(\"PM\") ? \"PM\" : null\n        try {\n            def end   = parseTimeToken(endRaw, null)\n            def start = parseTimeToken(startRaw, endMer)\n            if (!end.isAfter(start)) {\n                intervals.add([start: start, end: java.time.LocalTime.MAX, eod: true])\n            } else {\n                boolean eod = (end == java.time.LocalTime.MIDNIGHT)\n                intervals.add([start: start, end: (eod ? java.time.LocalTime.MAX : end), eod: eod]);\n            }\n        } catch (ignored) {}\n    }\n    intervals\n}\ndef computeOpenFlagsAndLabel = { List<Map> wdList ->\n    def row = wdList.find { (it.day ?: \"\").equalsIgnoreCase(CURRENT_DAY) }\n    String norm = normalizeStr(row?.time ?: \"\")\n    if (norm.equalsIgnoreCase(\"Open 24 hours\")) return [isOpen:true,  is24x7:true,  t_1:\"Open\",   t_2:\"24/7\"]\n    if (!row || norm.equalsIgnoreCase(\"Closed\")) return [isOpen:false, is24x7:false, t_1:\"Closed\", t_2:\"\"]\n    try {\n        def IN  = java.time.format.DateTimeFormatter.ofPattern(\"h:mm a\")\n        def now = java.time.LocalTime.parse(CURRENT_TIME.toUpperCase(), IN)\n        def active = parseIntervalsForToday(norm).find { iv ->\n            def start = (java.time.LocalTime) iv.start\n            def end   = (java.time.LocalTime) iv.end\n            (now.equals(start) || now.isAfter(start)) && (now.isBefore(end) || now.equals(end))\n        }\n        if (active) {\n            def OUT = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n            boolean eod = (boolean) active.eod\n            def endTime = (java.time.LocalTime) active.end\n            String label = eod ? \"12 AM\" : OUT.format(endTime).replace(\":00 \", \" \")\n            return [isOpen:true, is24x7:false, t_1:\"Open\", t_2:\"Closes \" + label]\n        }\n    } catch (ignored) {}\n    [isOpen:false,is24x7:false, t_1:\"Closed\", t_2:\"\"]\n}\n\n// ---------- Location + Distance ----------\ndef isValidVal = { v -> v != null && !(v.toString().trim().isEmpty()) && !v.toString().equalsIgnoreCase(\"undefined\") && v.toString() != \"-\" }\ndef buildLocation = { Map cols ->\n    def parts = []\n    def city    = getF(cols, ['_pr_City','City'])\n    def govArea = getF(cols, ['_pr_Governarate_Area','Governarate_Area'])\n    def country = getF(cols, ['_pr_Country','Country'])\n    if (isValidVal(city))    parts << city.toString().trim()\n    if (isValidVal(govArea)) parts << govArea.toString().trim()\n    if (isValidVal(country)) parts << country.toString().trim()\n    [location: parts.join(\", \"), location_id: (getF(cols, ['_pr_location_id','location_id']) ?: \"\").toString()]\n}\ndef haversineKm = { double lat1, double lon1, double lat2, double lon2 ->\n    double dLat = Math.toRadians(lat2 - lat1), dLon = Math.toRadians(lon2 - lon1)\n    double a = Math.sin(dLat/2)**2 + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLon/2)**2\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    EARTH_R_KM * c\n}\ndef computeRowDistanceKm = { Map cols ->\n    // include lowercase keys used in your data\n    def lat = toDbl(getF(cols, ['_pr_Latitude','_pr_latitude','latitude','Latitude']))\n    def lon = toDbl(getF(cols, ['_pr_Longitude','_pr_longitude','Longitude','longitude']))\n    if (lat == null || lon == null || ORIGIN_LAT == null || ORIGIN_LON == null) return null\n    haversineKm(ORIGIN_LAT, ORIGIN_LON, lat, lon)\n}\n// formatting rule for distance (one decimal if <10km; else integer)\ndef fmtDistance = { Double d ->\n    if (d == null) return null\n    if (d < 10.0d) {\n        double r = Math.round(d * 10) / 10.0d\n        return (r >= 10.0d) ? (long)Math.round(d) : r\n    }\n    return (long)Math.round(d)\n}\n\n// ---------- Bands & Specialities ----------\ndef normBandTokenLC = { String t ->\n    def x = trimLC(t); if (!x) return null\n    if (x in ['a','band_a','grade_a']) return 'a'\n    if (x in ['a+','a plus','aplus','a_plus']) return 'a+'\n    if (x in ['b','band_b','grade_b']) return 'b'\n    return x\n}\ndef canonBandOut = { String t -> (t == 'a') ? 'A' : (t == 'a+') ? 'A+' : (t == 'b') ? 'B' : t?.toUpperCase() }\ndef extractBandsCanon = { Map cols ->\n    def out = [] as LinkedHashSet\n    def bandVal = getF(cols, ['_pr_Band','Band','band'])\n    parseStringArray(bandVal).each { tok ->\n        def n = normBandTokenLC(tok); if (n) out << canonBandOut(n)\n    }\n    if (cols.A     == true) out << 'A'\n    if (cols.B     == true) out << 'B'\n    if (cols.Aplus == true || cols['A+'] == true || cols.A_plus == true || cols.APlus == true) out << 'A+'\n    out.toList()\n}\ndef extractSpecsLC = { Map cols ->\n    (parseStringArray(getF(cols, ['_pr_Speciality_details','Speciality_details','SpecialityDetails'])) +\n     parseStringArray(getF(cols, ['_pr_Speciality','Speciality'])))\n        .collect { trimLC(it) }\n        .findAll { it }\n        .toSet()\n}\n\n// ---------- Column coercer ----------\ndef coerceColumns = { Map cols ->\n    def out = new LinkedHashMap()\n    cols.each { k, v ->\n        def val = v\n        if (val instanceof CharSequence) {\n            String s = val.toString().trim()\n            if (s.contains('\\\\\\\"')) s = s.replace('\\\\\\\"','\"')\n\n            if (['_pr_weekdayDescriptions','weekdayDescriptions'].contains(k)) {\n                out[k] = toWeekdayList(s); return\n            }\n            if (['_pr_Band','Band','band',\n                  '_pr_Speciality_details','Speciality_details','SpecialityDetails',\n                  '_pr_grants','grants'].contains(k)) {\n                out[k] = parseStringArray(s); return\n            }\n            if (s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"false\") ||\n                s.equalsIgnoreCase(\"yes\")  || s.equalsIgnoreCase(\"no\")) {\n                out[k] = coercePrimitive(s); return\n            }\n            if (s ==~ /^-?\\d+(\\.\\d+)?$/) {\n                out[k] = (s.contains('.') ? Double.parseDouble(s) : Long.parseLong(s)); return\n            }\n            if ((s.startsWith(\"[\") && s.endsWith(\"]\")) || (s.startsWith(\"{\") && s.endsWith(\"}\"))) {\n                out[k] = s.startsWith(\"[\") ? parseArrayGeneric(s) : parseObjectGeneric(s); return\n            }\n            out[k] = s\n        } else {\n            out[k] = val\n        }\n    }\n    return out\n}\n\n// ---------- sort helpers (featured -> distance -> name) ----------\ndef isFeatured = { Map row ->\n    def f = getF(row, ['_pr_FeaturedProvider','FeaturedProvider'])\n    (f instanceof Boolean) ? f : (f?.toString()?.equalsIgnoreCase('true'))\n}\ndef compareRows = { Map a, Map b ->\n    int fa = isFeatured(a) ? 0 : 1\n    int fb = isFeatured(b) ? 0 : 1\n    if (fa != fb) return fa <=> fb\n\n    double da = (a.distance_km instanceof Number) ? ((Number)a.distance_km).doubleValue() : 1.0e15d\n    double db = (b.distance_km instanceof Number) ? ((Number)b.distance_km).doubleValue() : 1.0e15d\n    if (da != db) return da <=> db\n\n    String na = ('' + (getF(a, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    String nb = ('' + (getF(b, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    return na <=> nb\n}\n\n// ---------- Read filter inputs (MODIFIED: Use range_start and range_end instead of distance) ----------\ndef rawOH   = (binding?.hasVariable('openinghrs')) ? openinghrs?.toString()?.trim() : null // \"All\" | \"24/7\" | \"Open Now\"\ndef rawBand = (binding?.hasVariable('band')) ? band : null\ndef rawSpec = (binding?.hasVariable('speciality')) ? speciality : null\n\n// NEW: Get range_start and range_end instead of distance\ndef rawRangeStart = (binding?.hasVariable('range_start')) ? range_start : null\ndef rawRangeEnd = (binding?.hasVariable('range_end')) ? range_end : null\n\ndef wantBands = asList(rawBand).findAll { it != null && it.toString().trim() }\n        .collect { normBandTokenLC(it.toString()) }.findAll { it }.toSet()\ndef wantSpecs = asList(rawSpec).findAll { it != null && it.toString().trim() }\n    .collect { trimLC(it) }.findAll { it }.toSet()\n\n// NEW: Process range inputs to determine distance filtering criteria\ndef rangeStartKm = toDbl(rawRangeStart)\ndef rangeEndKm = toDbl(rawRangeEnd)\n\n// Determine if we should filter by distance range\nboolean hasDistanceFilter = (rangeStartKm != null || rangeEndKm != null)\n\nboolean noOH = (rawOH == null || rawOH == \"\" || rawOH == \"All\")\n\n// ---------- Return-all (no filters) ----------\nif (wantBands.isEmpty() && wantSpecs.isEmpty() && !hasDistanceFilter && noOH) {\n    def allRows = src.collect { row ->\n        def cols = (row.columns instanceof Map) ? row.columns : row\n        def coerced = coerceColumns(cols)\n\n        def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n        def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n        def open = computeOpenFlagsAndLabel(wdList)\n        def dkm = computeRowDistanceKm(coerced)\n        def loc = buildLocation(coerced)\n\n        coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n        coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n        coerced.location = loc.location\n        coerced.location_id = loc.location_id\n        coerced\n    }\n    allRows.sort(compareRows)\n    def totalCount = allRows.size()\n    return [\"countHospitals\": totalCount]\n}\n\n// ---------- AND filter + coerce all (MODIFIED: Use range-based distance filtering) ----------\ndef filtered = src.findAll { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def wdList = toWeekdayList(getF(cols, ['_pr_weekdayDescriptions','weekdayDescriptions']))\n\n    def rowBand = extractBandsCanon(cols).collect { normBandTokenLC(it) }.findAll { it } as Set\n    boolean bandOk = wantBands.isEmpty() || wantBands.every { rowBand.contains(it) }\n\n    def rowSpecs = extractSpecsLC(cols)\n    boolean specOk = wantSpecs.isEmpty() || wantSpecs.every { rowSpecs.contains(it) }\n\n    // NEW: Distance range filtering logic\n    def dkmTmp = computeRowDistanceKm(cols)\n    boolean distOk = true // Default to true if no distance filter\n    \n    if (hasDistanceFilter && dkmTmp != null) {\n        // If only range_start is provided, filter >= range_start\n        if (rangeStartKm != null && rangeEndKm == null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9)\n        }\n        // If only range_end is provided, filter <= range_end\n        else if (rangeStartKm == null && rangeEndKm != null) {\n            distOk = dkmTmp <= (rangeEndKm + 1e-9)\n        }\n        // If both are provided, filter within range [range_start, range_end]\n        else if (rangeStartKm != null && rangeEndKm != null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9) && dkmTmp <= (rangeEndKm + 1e-9)\n        }\n    } else if (hasDistanceFilter && dkmTmp == null) {\n        // If distance filter is requested but we can't calculate distance, exclude the row\n        distOk = false\n    }\n\n    def o = computeOpenFlagsAndLabel(wdList)\n    boolean ohOk = (rawOH == null || rawOH == \"\" || rawOH == \"All\") ? true\n                 : (rawOH == \"24/7\"     ? (o.is24x7 == true)\n                   : rawOH == \"Open Now\" ? (o.isOpen == true)\n                   : true)\n\n    bandOk && specOk && distOk && ohOk\n}.collect { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def coerced = coerceColumns(cols)\n\n    def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n    def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n    def open = computeOpenFlagsAndLabel(wdList)\n    def dkm = computeRowDistanceKm(coerced)\n    def loc = buildLocation(coerced)\n\n    coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n    coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n    coerced.location = loc.location\n    coerced.location_id = loc.location_id\n    coerced\n}\n\nfiltered.sort(compareRows)\ndef totalCount = filtered.size()\nreturn [\"countPharmacy\": totalCount]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"data":"{{ _sdiv9.outputs.objects }}",
					"distance":"{{ n_JHETh.outputs.governorte }}",
					"openinghrs":"{{ n_JHETh.outputs.opening_hrs }}",
					"day":"{{ n_JHETh.outputs.day }}",
					"time":"{{ n_JHETh.outputs.time }}",
					"latitude":"{{ n_JHETh.outputs.latitude }}",
					"longitude":"{{ n_JHETh.outputs.longitude }}",
					"range_start":"{{ n_JHETh.outputs.range_start }}",
					"range_end":"{{ n_JHETh.outputs.range_end }}",
					"band":{
						"source":"{{ n_JHETh.outputs.band }}",
						"ua:type":"mappedArray"
					},
					"speciality":{
						"source":"{{ n_JHETh.outputs.speciality }}",
						"ua:type":"mappedArray"
					}
				}
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@3",
			"id":"_61TkJ",
			"index":18,
			"inputs":{
				"variables":[
					{
						"source":"{{ _eXQK8.outputs.total_pharmacy_records_in_search }}",
						"value":"{{ _LjaEI.outputs.result.countPharmacy }}"
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"branch_condition",
				"resourceVersion":0,
				"resourceName":"branch_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@4",
			"id":"n_BxGyJ@4",
			"index":19,
			"inputs":{
				"name":"Branch 4",
				"conditions":{
					"filters":[
						{
							"property":"1",
							"filter":{
								"operator":"EQUAL",
								"value":"1"
							}
						}
					],
					"operator":"AND"
				}
			},
			"skip":false,
			"title":"",
			"type":"BRANCH_CONDITION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				}
			},
			"context":{
				"appName":"analytics_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"analytics_by_unifyapps_execute_query",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@4",
			"id":"_okOsh",
			"index":20,
			"inputs":{
				"outputSchema":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"total_records"
					],
					"properties":{
						"ProviderID":{
							"type":"string",
							"title":"ProviderID"
						},
						"Speciality":{
							"type":"string",
							"title":"Speciality"
						},
						"Address":{
							"type":"string",
							"title":"Address"
						},
						"medicineDelivery":{
							"type":"string",
							"title":"medicineDelivery"
						},
						"latitude":{
							"type":"number",
							"title":"latitude"
						},
						"FeaturedProvider":{
							"type":"string",
							"title":"FeaturedProvider"
						},
						"SpecialityDetails":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"SpecialityDetails"
						},
						"Band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"City":{
							"type":"string",
							"title":"City"
						},
						"Longitude":{
							"type":"number",
							"title":"Longitude"
						},
						"weekdayDescriptions":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"time":{
										"type":"string",
										"title":"time"
									},
									"day":{
										"type":"string",
										"title":"day"
									}
								},
								"additionalProperties":false
							},
							"title":"weekdayDescriptions"
						},
						"ProviderName":{
							"type":"string",
							"title":"ProviderName"
						},
						"Governarate_Area":{
							"type":"string",
							"title":"Governarate_Area"
						},
						"mapsURL":{
							"type":"string",
							"title":"mapsURL"
						},
						"Country":{
							"type":"string",
							"title":"Country"
						},
						"ContactNumber":{
							"type":"string",
							"title":"ContactNumber"
						},
						"ProviderType":{
							"type":"string",
							"title":"ProviderType"
						},
						"favorite":{
							"type":"string",
							"title":"Favorite"
						},
						"Deleted_fav":{
							"type":"string",
							"title":"Deleted Fav"
						},
						"total_records":{
							"type":"string",
							"title":"Total Records"
						}
					}
				},
				"query":"SELECT\n  np._pr_Longitude, np._pr_Latitude, np._pr_ProviderType, np.id\nFROM ENTITY_oman_network_providers np\nWHERE deleted = false AND\n  LOWER(np._pr_ProviderType) = LOWER('Diagnostic Center')\n  AND ('{{ n_JHETh.outputs.city }}' IS NULL OR '{{ n_JHETh.outputs.city }}' = '' OR LOWER(np._pr_City) = LOWER('{{ n_JHETh.outputs.city }}'))\n  AND ('{{ n_JHETh.outputs.Area }}' IS NULL OR '{{ n_JHETh.outputs.Area }}' = '' OR LOWER(np._pr_Governarate_Area) = LOWER('{{ n_JHETh.outputs.Area }}'))\n  AND ('{{ n_JHETh.outputs.Country }}' IS NULL OR '{{ n_JHETh.outputs.Country }}' = '' OR LOWER(np._pr_Country) = LOWER('{{ n_JHETh.outputs.Country }}'))\n  AND ('{{ n_JHETh.outputs.search }}' IS NULL OR '{{ n_JHETh.outputs.search }}' = '' OR LOWER(np._pr_ProviderName) LIKE LOWER('%{{ n_JHETh.outputs.search }}%') OR LOWER(np._pr_Speciality) LIKE LOWER('%{{ n_JHETh.outputs.search }}%'))\n  AND ('{{ n_JHETh.outputs.tab }}' IS NULL OR '{{ n_JHETh.outputs.tab }}' = '' OR LOWER(np._pr_ProviderType) = LOWER('{{ n_JHETh.outputs.tab }}'));\n",
				"group":"ENTITY_REPORTING"
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false,
					"slidingWindowType":"COUNT_BASED"
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"unit":"MINUTES",
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Analytics by UnifyApps",
			"title":"Execute Analytics SQL Query",
			"type":"ACTION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{
					"root":{}
				},
				"visibleOptionalFields":[
					"root.parameters.band.items",
					"root.parameters.speciality.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":12,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@4",
			"id":"_DciO8",
			"index":21,
			"inputs":{
				"output":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"countDiagnostics":{
							"type":"integer",
							"title":"Count Diagnostics"
						}
					}
				},
				"input":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"band":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Band"
						},
						"data":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Data"
						},
						"speciality":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Speciality"
						},
						"distance":{
							"type":"string",
							"title":"Distance"
						},
						"openinghrs":{
							"type":"string",
							"title":"openinghrs"
						},
						"day":{
							"type":"string",
							"title":"Day"
						},
						"time":{
							"type":"string",
							"title":"Time"
						},
						"latitude":{
							"type":"string",
							"title":"Latitude"
						},
						"longitude":{
							"type":"string",
							"title":"Longitude"
						},
						"range_start":{
							"type":"string",
							"title":"Range Start"
						},
						"range_end":{
							"type":"string",
							"title":"Range End"
						}
					}
				},
				"code":"// ---------- Early exit for SQL \"no rows\" ----------\ndef d0 = (binding?.hasVariable('data')) ? data : null\nif (d0 instanceof Map && d0.size() == 1 && d0.containsKey('hasMore')) {\n    return d0 // {\"result\":{\"hasMore\":false}}\n}\n\n// ---------- Load rows ----------\ndef src = (d0 instanceof Collection) ? d0 as List\n         : (d0 instanceof Map       ) ? [d0]\n         : []\nif (src.isEmpty()) return []\n\n// ---------- Constants ----------\nfinal double EARTH_R_KM = 6371.0088d\n\n// ---------- Get current Oman time ----------\nimport java.time.*\nimport java.time.format.*\n\ndef omanZone = ZoneId.of(\"Asia/Muscat\")\ndef omanNow = ZonedDateTime.now(omanZone)\nfinal String CURRENT_DAY = omanNow.getDayOfWeek().getDisplayName(java.time.format.TextStyle.FULL, Locale.ENGLISH)\nfinal String CURRENT_TIME = omanNow.format(DateTimeFormatter.ofPattern(\"h:mm a\"))\n\n// ---------- Small helpers ----------\ndef asList  = { v -> (v == null) ? [] : (v instanceof Collection ? v as List : [v]) }\ndef trimLC  = { s -> s?.toString()?.trim()?.toLowerCase() }\ndef toDbl   = { v ->\n    if (v == null) return null\n    if (v instanceof Number) return ((Number)v).doubleValue()\n    def s = v.toString().trim()\n    if (!s || s.equalsIgnoreCase('null') || s.equalsIgnoreCase('na')) return null\n    try { return Double.parseDouble(s) } catch (ignored) { return null }\n}\ndef getF = { Map m, List keys -> for (k in keys) { if (m.containsKey(k) && m[k] != null) return m[k] }; return null }\n\n// ---------- Use input origin (latitude/longitude) WITHOUT fallback ----------\ndef ORIGIN_LAT = toDbl(binding?.hasVariable('latitude') ? latitude : -1)\ndef ORIGIN_LON = toDbl(binding?.hasVariable('longitude') ? longitude : -1)\n\n// ---------- Normalize / JSON-ish parsing (no JsonSlurper) ----------\ndef normalizeStr = { String s ->\n    if (s == null) return \"\"\n    s.replaceAll(\"[\\u2013\\u2014\\u2212]\", \"-\")\n     .replaceAll(\"[\\u2009\\u202F\\u00A0]\", \" \")\n     .replaceAll(\"\\\\s*,\\\\s*\", \",\")\n     .replaceAll(\"\\\\s*-\\\\s*\", \"-\")\n     .replaceAll(\"\\\\s+\", \" \")\n     .trim()\n}\ndef coercePrimitive = { String t ->\n    if (t == null) return null\n    def x = t.trim()\n    if (!x) return \"\"\n    if ((x.startsWith('\"') && x.endsWith('\"')) || (x.startsWith(\"'\") && x.endsWith(\"'\"))) {\n        x = x.substring(1, x.length()-1)\n    }\n    if (x.equalsIgnoreCase(\"true\"))  return true\n    if (x.equalsIgnoreCase(\"false\")) return false\n    if (x.equalsIgnoreCase(\"yes\"))   return true\n    if (x.equalsIgnoreCase(\"no\"))    return false\n    if (x ==~ /^-?\\d+$/)             return Long.parseLong(x)\n    if (x ==~ /^-?\\d+\\.\\d+$/)        return Double.parseDouble(x)\n    return x\n}\ndef parseArrayGeneric = { String arr ->\n    String s = arr?.trim() ?: \"\"\n    if (!s.startsWith(\"[\") || !s.endsWith(\"]\")) return s\n\n    if (s.contains(\"{\")) {\n        def blocks = (s =~ /\\{[^}]*\\}/)\n        def out = []\n        blocks.each { m -> out << parseObjectGeneric(m[0]) }\n        if (!out.isEmpty()) return out\n    }\n\n    def tokens = []\n    def qt = (s =~ /\"(.*?)\"|'(.*?)'/)\n    qt.each { _, g1, g2 -> tokens << (g1 ?: g2) }\n    if (!tokens.isEmpty()) return tokens.collect { coercePrimitive(it) }\n\n    def inner = s.substring(1, s.length()-1)\n    return inner.split(/\\s*,\\s*/).findAll { it != null && it.trim() }.collect { coercePrimitive(it) }\n}\ndef parseObjectGeneric = { String obj ->\n    String o = obj?.trim() ?: \"\"\n    if (!o.startsWith(\"{\") || !o.endsWith(\"}\")) return o\n    def map = [:]\n\n    def arrRe = (o =~ /\"([^\"]+)\"\\s*:\\s*(\\[[^\\]]*\\])/)\n    arrRe.each { m -> map[m[1]] = parseArrayGeneric(m[2]) }\n\n    def strRe = (o =~ /\"([^\"]+)\"\\s*:\\s*\"([^\"]*)\"/)\n    strRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2] }\n\n    def numRe = (o =~ /\"([^\"]+)\"\\s*:\\s*([-]?\\d+(?:\\.\\d+)?)/)\n    numRe.each { m ->\n        if (!map.containsKey(m[1])) map[m[1]] = (m[2].contains('.') ? Double.parseDouble(m[2]) : Long.parseLong(m[2]))\n    }\n\n    def boolRe = (o =~ /\"([^\"]+)\"\\s*:\\s*((?i:true|false))/)\n    boolRe.each { m -> if (!map.containsKey(m[1])) map[m[1]] = m[2].equalsIgnoreCase(\"true\") }\n\n    return map\n}\ndef parseStringArray = { v ->\n    if (v == null) return []\n    if (v instanceof Collection) return v.collect { it?.toString() }\n    def s = v.toString().trim(); if (!s) return []\n    if ((s.startsWith('[') && s.endsWith(']')) || (s.startsWith('(') && s.endsWith(')'))) {\n        def u = s.contains('\\\\\\\"') ? s.replace('\\\\\\\"','\"') : s\n        def toks = []\n        def m = (u =~ /\"(.*?)\"|'(.*?)'/)\n        m.each { _, g1, g2 -> def tok = (g1 ?: g2); if (tok != null && tok.trim()) toks << tok }\n        if (toks.isEmpty()) {\n            def inner = u.substring(1, u.length()-1)\n            toks = inner.split(/\\s*,\\s*|\\s*\\|\\s*/)\n        }\n        return toks.collect { it?.toString() }\n    }\n    return s.split(/\\s*,\\s*|\\s*\\|\\s*/).collect { it?.toString() }\n}\n\n// ---------- Hours ----------\ndef toWeekdayList = { Object wd ->\n    if (wd == null) return []\n    if (wd instanceof Collection) {\n        return wd.collect { it instanceof Map ? [day: it.day?.toString(), time: it.time?.toString()] : it }\n    }\n    String u = wd.toString().trim()\n    if (!u) return []\n    if (u.contains('\\\\\\\"')) u = u.replace('\\\\\\\"','\"')\n    def blocks = (u =~ /\\{[^}]*\\}/)\n    def out = []\n    blocks.each { m ->\n        String ob = m[0]\n        def dm = (ob =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n        def tm = (ob =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n        if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n    }\n    if (out.isEmpty() && u.startsWith('[') && u.endsWith(']')) {\n        def parts = u.substring(1, u.length()-1).split(/}\\s*,\\s*\\{/)\n        parts.each { p ->\n            String obj = p\n            if (!obj.startsWith('{')) obj = '{' + obj\n            if (!obj.endsWith('}'))  obj = obj + '}'\n            def dm = (obj =~ /\"day\"\\s*:\\s*\"([^\"]+)\"/)\n            def tm = (obj =~ /\"time\"\\s*:\\s*\"([^\"]+)\"/)\n            if (dm.find() && tm.find()) out << [day: dm.group(1), time: normalizeStr(tm.group(1))]\n        }\n    }\n    out\n}\ndef parseTimeToken = { String token, String meridiemHint ->\n    def IN = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n    String t = token.trim()\n    if (!(t ==~ /(?i).*(AM|PM)$/)) {\n        if (meridiemHint == null) throw new RuntimeException(\"Missing AM/PM for \" + t)\n        t += \" \" + meridiemHint\n    }\n    java.time.LocalTime.parse(t.toUpperCase(), IN)\n}\ndef parseIntervalsForToday = { String timeStr ->\n    String s = normalizeStr(timeStr)\n    if (s.equalsIgnoreCase(\"Closed\")) return []\n    if (s.equalsIgnoreCase(\"Open 24 hours\")) return [[start: java.time.LocalTime.MIN, end: java.time.LocalTime.MAX, eod: true]]\n    def intervals = []\n    for (String part : s.split(\",\")) {\n        String[] bits = part.trim().split(\"-\"); if (bits.length != 2) continue\n        String startRaw = bits[0].trim(), endRaw = bits[1].trim()\n        String endMer = endRaw.toUpperCase().endsWith(\"AM\") ? \"AM\" : endRaw.toUpperCase().endsWith(\"PM\") ? \"PM\" : null\n        try {\n            def end   = parseTimeToken(endRaw, null)\n            def start = parseTimeToken(startRaw, endMer)\n            if (!end.isAfter(start)) {\n                intervals.add([start: start, end: java.time.LocalTime.MAX, eod: true])\n            } else {\n                boolean eod = (end == java.time.LocalTime.MIDNIGHT)\n                intervals.add([start: start, end: (eod ? java.time.LocalTime.MAX : end), eod: eod]);\n            }\n        } catch (ignored) {}\n    }\n    intervals\n}\ndef computeOpenFlagsAndLabel = { List<Map> wdList ->\n    def row = wdList.find { (it.day ?: \"\").equalsIgnoreCase(CURRENT_DAY) }\n    String norm = normalizeStr(row?.time ?: \"\")\n    if (norm.equalsIgnoreCase(\"Open 24 hours\")) return [isOpen:true,  is24x7:true,  t_1:\"Open\",   t_2:\"24/7\"]\n    if (!row || norm.equalsIgnoreCase(\"Closed\")) return [isOpen:false, is24x7:false, t_1:\"Closed\", t_2:\"\"]\n    try {\n        def IN  = java.time.format.DateTimeFormatter.ofPattern(\"h:mm a\")\n        def now = java.time.LocalTime.parse(CURRENT_TIME.toUpperCase(), IN)\n        def active = parseIntervalsForToday(norm).find { iv ->\n            def start = (java.time.LocalTime) iv.start\n            def end   = (java.time.LocalTime) iv.end\n            (now.equals(start) || now.isAfter(start)) && (now.isBefore(end) || now.equals(end))\n        }\n        if (active) {\n            def OUT = java.time.format.DateTimeFormatter.ofPattern(\"h[:mm] a\")\n            boolean eod = (boolean) active.eod\n            def endTime = (java.time.LocalTime) active.end\n            String label = eod ? \"12 AM\" : OUT.format(endTime).replace(\":00 \", \" \")\n            return [isOpen:true, is24x7:false, t_1:\"Open\", t_2:\"Closes \" + label]\n        }\n    } catch (ignored) {}\n    [isOpen:false,is24x7:false, t_1:\"Closed\", t_2:\"\"]\n}\n\n// ---------- Location + Distance ----------\ndef isValidVal = { v -> v != null && !(v.toString().trim().isEmpty()) && !v.toString().equalsIgnoreCase(\"undefined\") && v.toString() != \"-\" }\ndef buildLocation = { Map cols ->\n    def parts = []\n    def city    = getF(cols, ['_pr_City','City'])\n    def govArea = getF(cols, ['_pr_Governarate_Area','Governarate_Area'])\n    def country = getF(cols, ['_pr_Country','Country'])\n    if (isValidVal(city))    parts << city.toString().trim()\n    if (isValidVal(govArea)) parts << govArea.toString().trim()\n    if (isValidVal(country)) parts << country.toString().trim()\n    [location: parts.join(\", \"), location_id: (getF(cols, ['_pr_location_id','location_id']) ?: \"\").toString()]\n}\ndef haversineKm = { double lat1, double lon1, double lat2, double lon2 ->\n    double dLat = Math.toRadians(lat2 - lat1), dLon = Math.toRadians(lon2 - lon1)\n    double a = Math.sin(dLat/2)**2 + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLon/2)**2\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    EARTH_R_KM * c\n}\ndef computeRowDistanceKm = { Map cols ->\n    // include lowercase keys used in your data\n    def lat = toDbl(getF(cols, ['_pr_Latitude','_pr_latitude','latitude','Latitude']))\n    def lon = toDbl(getF(cols, ['_pr_Longitude','_pr_longitude','Longitude','longitude']))\n    if (lat == null || lon == null || ORIGIN_LAT == null || ORIGIN_LON == null) return null\n    haversineKm(ORIGIN_LAT, ORIGIN_LON, lat, lon)\n}\n// formatting rule for distance (one decimal if <10km; else integer)\ndef fmtDistance = { Double d ->\n    if (d == null) return null\n    if (d < 10.0d) {\n        double r = Math.round(d * 10) / 10.0d\n        return (r >= 10.0d) ? (long)Math.round(d) : r\n    }\n    return (long)Math.round(d)\n}\n\n// ---------- Bands & Specialities ----------\ndef normBandTokenLC = { String t ->\n    def x = trimLC(t); if (!x) return null\n    if (x in ['a','band_a','grade_a']) return 'a'\n    if (x in ['a+','a plus','aplus','a_plus']) return 'a+'\n    if (x in ['b','band_b','grade_b']) return 'b'\n    return x\n}\ndef canonBandOut = { String t -> (t == 'a') ? 'A' : (t == 'a+') ? 'A+' : (t == 'b') ? 'B' : t?.toUpperCase() }\ndef extractBandsCanon = { Map cols ->\n    def out = [] as LinkedHashSet\n    def bandVal = getF(cols, ['_pr_Band','Band','band'])\n    parseStringArray(bandVal).each { tok ->\n        def n = normBandTokenLC(tok); if (n) out << canonBandOut(n)\n    }\n    if (cols.A     == true) out << 'A'\n    if (cols.B     == true) out << 'B'\n    if (cols.Aplus == true || cols['A+'] == true || cols.A_plus == true || cols.APlus == true) out << 'A+'\n    out.toList()\n}\ndef extractSpecsLC = { Map cols ->\n    (parseStringArray(getF(cols, ['_pr_Speciality_details','Speciality_details','SpecialityDetails'])) +\n     parseStringArray(getF(cols, ['_pr_Speciality','Speciality'])))\n        .collect { trimLC(it) }\n        .findAll { it }\n        .toSet()\n}\n\n// ---------- Column coercer ----------\ndef coerceColumns = { Map cols ->\n    def out = new LinkedHashMap()\n    cols.each { k, v ->\n        def val = v\n        if (val instanceof CharSequence) {\n            String s = val.toString().trim()\n            if (s.contains('\\\\\\\"')) s = s.replace('\\\\\\\"','\"')\n\n            if (['_pr_weekdayDescriptions','weekdayDescriptions'].contains(k)) {\n                out[k] = toWeekdayList(s); return\n            }\n            if (['_pr_Band','Band','band',\n                  '_pr_Speciality_details','Speciality_details','SpecialityDetails',\n                  '_pr_grants','grants'].contains(k)) {\n                out[k] = parseStringArray(s); return\n            }\n            if (s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"false\") ||\n                s.equalsIgnoreCase(\"yes\")  || s.equalsIgnoreCase(\"no\")) {\n                out[k] = coercePrimitive(s); return\n            }\n            if (s ==~ /^-?\\d+(\\.\\d+)?$/) {\n                out[k] = (s.contains('.') ? Double.parseDouble(s) : Long.parseLong(s)); return\n            }\n            if ((s.startsWith(\"[\") && s.endsWith(\"]\")) || (s.startsWith(\"{\") && s.endsWith(\"}\"))) {\n                out[k] = s.startsWith(\"[\") ? parseArrayGeneric(s) : parseObjectGeneric(s); return\n            }\n            out[k] = s\n        } else {\n            out[k] = val\n        }\n    }\n    return out\n}\n\n// ---------- sort helpers (featured -> distance -> name) ----------\ndef isFeatured = { Map row ->\n    def f = getF(row, ['_pr_FeaturedProvider','FeaturedProvider'])\n    (f instanceof Boolean) ? f : (f?.toString()?.equalsIgnoreCase('true'))\n}\ndef compareRows = { Map a, Map b ->\n    int fa = isFeatured(a) ? 0 : 1\n    int fb = isFeatured(b) ? 0 : 1\n    if (fa != fb) return fa <=> fb\n\n    double da = (a.distance_km instanceof Number) ? ((Number)a.distance_km).doubleValue() : 1.0e15d\n    double db = (b.distance_km instanceof Number) ? ((Number)b.distance_km).doubleValue() : 1.0e15d\n    if (da != db) return da <=> db\n\n    String na = ('' + (getF(a, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    String nb = ('' + (getF(b, ['_pr_ProviderName','ProviderName']) ?: '')).toLowerCase()\n    return na <=> nb\n}\n\n// ---------- Read filter inputs (MODIFIED: Use range_start and range_end instead of distance) ----------\ndef rawOH   = (binding?.hasVariable('openinghrs')) ? openinghrs?.toString()?.trim() : null // \"All\" | \"24/7\" | \"Open Now\"\ndef rawBand = (binding?.hasVariable('band')) ? band : null\ndef rawSpec = (binding?.hasVariable('speciality')) ? speciality : null\n\n// NEW: Get range_start and range_end instead of distance\ndef rawRangeStart = (binding?.hasVariable('range_start')) ? range_start : null\ndef rawRangeEnd = (binding?.hasVariable('range_end')) ? range_end : null\n\ndef wantBands = asList(rawBand).findAll { it != null && it.toString().trim() }\n        .collect { normBandTokenLC(it.toString()) }.findAll { it }.toSet()\ndef wantSpecs = asList(rawSpec).findAll { it != null && it.toString().trim() }\n    .collect { trimLC(it) }.findAll { it }.toSet()\n\n// NEW: Process range inputs to determine distance filtering criteria\ndef rangeStartKm = toDbl(rawRangeStart)\ndef rangeEndKm = toDbl(rawRangeEnd)\n\n// Determine if we should filter by distance range\nboolean hasDistanceFilter = (rangeStartKm != null || rangeEndKm != null)\n\nboolean noOH = (rawOH == null || rawOH == \"\" || rawOH == \"All\")\n\n// ---------- Return-all (no filters) ----------\nif (wantBands.isEmpty() && wantSpecs.isEmpty() && !hasDistanceFilter && noOH) {\n    def allRows = src.collect { row ->\n        def cols = (row.columns instanceof Map) ? row.columns : row\n        def coerced = coerceColumns(cols)\n\n        def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n        def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n        def open = computeOpenFlagsAndLabel(wdList)\n        def dkm = computeRowDistanceKm(coerced)\n        def loc = buildLocation(coerced)\n\n        coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n        coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n        coerced.location = loc.location\n        coerced.location_id = loc.location_id\n        coerced\n    }\n    allRows.sort(compareRows)\n    def totalCount = allRows.size()\n    return [\"countHospitals\": totalCount]\n}\n\n// ---------- AND filter + coerce all (MODIFIED: Use range-based distance filtering) ----------\ndef filtered = src.findAll { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def wdList = toWeekdayList(getF(cols, ['_pr_weekdayDescriptions','weekdayDescriptions']))\n\n    def rowBand = extractBandsCanon(cols).collect { normBandTokenLC(it) }.findAll { it } as Set\n    boolean bandOk = wantBands.isEmpty() || wantBands.every { rowBand.contains(it) }\n\n    def rowSpecs = extractSpecsLC(cols)\n    boolean specOk = wantSpecs.isEmpty() || wantSpecs.every { rowSpecs.contains(it) }\n\n    // NEW: Distance range filtering logic\n    def dkmTmp = computeRowDistanceKm(cols)\n    boolean distOk = true // Default to true if no distance filter\n    \n    if (hasDistanceFilter && dkmTmp != null) {\n        // If only range_start is provided, filter >= range_start\n        if (rangeStartKm != null && rangeEndKm == null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9)\n        }\n        // If only range_end is provided, filter <= range_end\n        else if (rangeStartKm == null && rangeEndKm != null) {\n            distOk = dkmTmp <= (rangeEndKm + 1e-9)\n        }\n        // If both are provided, filter within range [range_start, range_end]\n        else if (rangeStartKm != null && rangeEndKm != null) {\n            distOk = dkmTmp >= (rangeStartKm - 1e-9) && dkmTmp <= (rangeEndKm + 1e-9)\n        }\n    } else if (hasDistanceFilter && dkmTmp == null) {\n        // If distance filter is requested but we can't calculate distance, exclude the row\n        distOk = false\n    }\n\n    def o = computeOpenFlagsAndLabel(wdList)\n    boolean ohOk = (rawOH == null || rawOH == \"\" || rawOH == \"All\") ? true\n                 : (rawOH == \"24/7\"     ? (o.is24x7 == true)\n                   : rawOH == \"Open Now\" ? (o.isOpen == true)\n                   : true)\n\n    bandOk && specOk && distOk && ohOk\n}.collect { row ->\n    def cols = (row.columns instanceof Map) ? row.columns : row\n    def coerced = coerceColumns(cols)\n\n    def wd = getF(coerced, ['_pr_weekdayDescriptions','weekdayDescriptions'])\n    def wdList = (wd instanceof Collection) ? wd : toWeekdayList(wd?.toString())\n    def open = computeOpenFlagsAndLabel(wdList)\n    def dkm = computeRowDistanceKm(coerced)\n    def loc = buildLocation(coerced)\n\n    coerced.distance_km = (dkm == null) ? null : fmtDistance(dkm)\n    coerced.t_1 = open.t_1; coerced.t_2 = open.t_2\n    coerced.location = loc.location\n    coerced.location_id = loc.location_id\n    coerced\n}\n\nfiltered.sort(compareRows)\ndef totalCount = filtered.size()\nreturn [\"countDiagnostics\": totalCount]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"data":"{{ _okOsh.outputs.objects }}",
					"distance":"{{ n_JHETh.outputs.governorte }}",
					"openinghrs":"{{ n_JHETh.outputs.opening_hrs }}",
					"day":"{{ n_JHETh.outputs.day }}",
					"time":"{{ n_JHETh.outputs.time }}",
					"latitude":"{{ n_JHETh.outputs.latitude }}",
					"longitude":"{{ n_JHETh.outputs.longitude }}",
					"range_start":"{{ n_JHETh.outputs.range_start }}",
					"range_end":"{{ n_JHETh.outputs.range_end }}",
					"band":{
						"source":"{{ n_JHETh.outputs.band }}",
						"ua:type":"mappedArray"
					},
					"speciality":{
						"source":"{{ n_JHETh.outputs.speciality }}",
						"ua:type":"mappedArray"
					}
				}
			},
			"options":{
				"bulkheadConfig":{
					"enabled":false,
					"maxLeaseTimeUnit":"SECONDS",
					"maxWaitDurationUnit":"SECONDS"
				},
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false,
					"usagePolicy":"ALWAYS"
				},
				"circuitBreakerConfig":{
					"enabled":false
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false,
					"postHooks":[
						
					],
					"preHooks":[
						
					]
				},
				"logConfig":{
					"enabled":false,
					"logPolicies":[
						
					]
				},
				"rateLimitConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"STOP",
				"telemetryConfig":{
					"enableTelemetry":false,
					"metricConfigs":[
						
					]
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":112,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_BxGyJ@_TTYrf-1@4",
			"id":"_4a3AQ",
			"index":22,
			"inputs":{
				"variables":[
					{
						"source":"{{ _2vG2F.outputs.total_diagnostic_records_in_search }}",
						"value":"{{ _DciO8.outputs.result.countDiagnostics }}"
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.result.ProviderID",
					"root.result.Speciality",
					"root.result.Address",
					"root.result.latitude",
					"root.result.FeaturedProvider",
					"root.result.City",
					"root.result.Longitude",
					"root.result.weekdayDescriptions.source",
					"root.result.weekdayDescriptions.ua:type",
					"root.result.weekdayDescriptions.items.day",
					"root.result.weekdayDescriptions.items.time",
					"root.result.ProviderName",
					"root.result.Governarate_Area",
					"root.result.mapsURL",
					"root.result.Country",
					"root.result.ContactNumber",
					"root.result.ProviderType",
					"root.result.distance_km",
					"root.result.t_1",
					"root.result.t_2",
					"root.result.location",
					"root.result.location_id"
				]
			},
			"context":{
				"appName":"callables",
				"resourceVersion":12,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_TTYrf-1",
			"id":"n_KQyKt",
			"index":23,
			"inputs":{
				"result":{
					"total_hospital_records_in_search":"{{ n_KSDkd.outputs.total_hospital_records_in_search }}",
					"total_clinic_records_in_search":"{{ _4Jeol.outputs.total_clinics_records_in_search }}",
					"total_pharmacy_records_in_search":"{{ _eXQK8.outputs.total_pharmacy_records_in_search }}",
					"total_diagnostic_records_in_search":"{{ _2vG2F.outputs.total_diagnostic_records_in_search }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":30179,
	"schemaReferences":[
		"entity|e_code_snippet|e_68c8849fc0c3121802a9edc3"
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":11
}