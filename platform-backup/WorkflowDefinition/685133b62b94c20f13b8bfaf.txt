{
	"appsUsed":[
		
	],
	"createdTime":1751383917087,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1759615002421,
		"deployedBy":1,
		"deployedDefinitionId":"68e1981a5045f405579af0f9",
		"status":"DEPLOYED",
		"version":67,
		"workflowVersion":84
	},
	"description":"This automation converts the thinking_agent_without_tools models to agent_system_prompt_without_tools(default) response format.",
	"edges":[
		{
			"fromNodeId":"n_1XNM7",
			"priority":0,
			"skip":false,
			"toNodeId":"_zErEh",
			"type":"next"
		},
		{
			"fromNodeId":"_zErEh",
			"priority":0,
			"skip":false,
			"toNodeId":"n_KF3n3",
			"type":"next"
		},
		{
			"fromNodeId":"n_KF3n3",
			"priority":0,
			"skip":false,
			"toNodeId":"n_ggUk3",
			"type":"next"
		}
	],
	"grants":{
		"configs":[
			{
				"permissions":[
					"V"
				],
				"principalType":"GLOBAL"
			}
		]
	},
	"id":"685133b62b94c20f13b8bfaf",
	"lastModifiedBy":1,
	"lcName":"thinkingagentwithtoolsresponseconverter",
	"modifiedTime":1759685412432,
	"name":"ThinkingAgentWithToolsResponseConverter",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":444,
				"resourceName":"callables_from_automation"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_tGkfr-1",
			"id":"n_1XNM7",
			"index":0,
			"inputs":{
				"result":{
					"type":"object",
					"properties":{
						"llmResponse":{
							"type":"string",
							"title":"llmResponse"
						},
						"toolsToExecute":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"name":{
										"type":"string",
										"title":"name"
									},
									"arguments":{
										"type":"string",
										"title":"arguments"
									}
								},
								"additionalProperties":false
							},
							"title":"toolsToExecute"
						}
					},
					"additionalProperties":false
				},
				"setup":{
					"type":"object",
					"properties":{
						"llmResponse":{
							"type":"string",
							"title":"llmResponse"
						}
					},
					"additionalProperties":false,
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via automation",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":448,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_tGkfr-1",
			"id":"_zErEh",
			"index":0,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"thought":{
							"type":"string",
							"title":"thought"
						},
						"finalAnswer":{
							"type":"string",
							"title":"finalAnswer"
						},
						"toolCall":{
							"type":"object",
							"title":"toolCall",
							"properties":{
								"name":{
									"type":"string",
									"title":"name"
								},
								"arguments":{
									"type":"object",
									"properties":{},
									"additionalProperties":false,
									"title":"arguments"
								}
							},
							"required":[]
						},
						"finalLlmResponse":{
							"type":"string",
							"title":"finalLlmResponse"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"llmResponse":{
							"type":"string",
							"title":"llmResponse"
						}
					},
					"additionalProperties":false
				},
				"compile_static":false,
				"code":"def llmResponse = binding.hasVariable(\"llmResponse\") ? binding.getVariable(\"llmResponse\") : \"\"\n\ndef thinkContent = getThinkContent(llmResponse)\ndef thought = (thinkContent != null)?thinkContent:getThought(llmResponse)\ndef finalAnswer = getFinalAnswer(llmResponse)\ndef toolCall = getToolCall(llmResponse)\n\ndef finalLlmResponse = \"\"\nif( thought!=null && thought.size()>0){\n    finalLlmResponse += \"Thought: \"+thought\n}\nif (finalAnswer!=null && finalAnswer.size()>0){\n    finalLlmResponse += \"\\nFinalAnswer: \"+finalAnswer\n}\n\nreturn [ thought: thought, finalAnswer: finalAnswer, toolCall: toolCall , finalLlmResponse: finalLlmResponse]\n\ndef getThought(String llmResponse) {    \n    // JSON parsing\n    def jsonObjects = parseAllJsonObjects(llmResponse)\n    def thought = extractLargestField(jsonObjects, \"thought\")\n    if (thought) return thought\n    \n    // Fallback to regex extraction\n    def thoughtPattern = /(?s)thought(.*?)final_answer/\n    def thoughtMatch = (llmResponse =~ thoughtPattern)\n    def extractedThought = thoughtMatch ? thoughtMatch[0][1].trim() : null\n    return extractedThought ? cleanJsonString(extractedThought) : null\n}\n\ndef getFinalAnswer(String llmResponse) {\n    // JSON parsing\n    def jsonObjects = parseAllJsonObjects(llmResponse)\n    def finalAnswer = extractLargestField(jsonObjects, \"final_answer\")\n    if (finalAnswer) return finalAnswer\n    \n    // Fallback to regex extraction\n    def finalAnswerPattern = /(?s)final_answer(.*)/\n    def finalAnswerMatch = (llmResponse =~ finalAnswerPattern)\n    def extractedAnswer = finalAnswerMatch ? finalAnswerMatch[0][1].trim() : null\n    return extractedAnswer ? cleanJsonString(extractedAnswer) : null\n}\n\ndef getToolCall(String llmResponse) {\n    def jsonObjects = parseAllJsonObjects(llmResponse)\n    def largestToolCall = null\n    def largestSize = 0\n    \n    jsonObjects.each { jsonObj ->\n        def toolCall = null\n        if (jsonObj.containsKey('tool_call')) {\n            toolCall = parseToolCallObject(jsonObj.tool_call)\n        } else if (jsonObj.containsKey('tool_calls')) {\n            toolCall = parseToolCallObject(jsonObj.tool_calls)\n        }\n        \n        if (toolCall && toolCall.toString().length() > largestSize) {\n            largestSize = toolCall.toString().length()\n            largestToolCall = toolCall\n        }\n    }\n    \n    return largestToolCall ?: [name: \"\", arguments: [:]]\n}\n\ndef getThinkContent(String llmResponse) {\n    def thinkPattern = /(?s)<think>(.*?)<\\/think>/\n    def thinkMatch = (llmResponse =~ thinkPattern)\n    return thinkMatch ? thinkMatch[0][1].trim() : \"\"\n}\n\n// Helper functions\n\ndef removeThinkTags(String text) {\n    return text.replaceAll(/(?s)<think>(.*?)<\\/think>/, \"\").trim()\n}\n\ndef parseAllJsonObjects(String text) {\n    def cleanedText = removeThinkTags(text)\n    def jsonObjects = []\n    \n    // Strategy 1: Direct JSON string parsing\n    jsonObjects.addAll(parseDirectJson(cleanedText))\n    \n    // Strategy 2: JSON from code blocks\n    jsonObjects.addAll(parseJsonFromCodeBlocks(cleanedText))\n    \n    // Strategy 3: Find all JSON objects with bracket matching\n    jsonObjects.addAll(findAndParseJsonObjects(cleanedText))\n    \n    return jsonObjects\n}\n\ndef parseDirectJson(String text) {\n    def jsonObjects = []\n    try {\n        def startIndex = text.indexOf('{')\n        def endIndex = text.lastIndexOf('}')\n        \n        if (startIndex != -1 && endIndex != -1 && endIndex > startIndex) {\n            def jsonStr = text.substring(startIndex, endIndex + 1).trim()\n            def jsonObj = com.unifyapps.infra.utils.JsonUtils.fromJson(jsonStr, Map.class)\n            if (jsonObj) jsonObjects.add(jsonObj)\n        }\n    } catch (Exception e) {\n        // Ignore parsing errors\n    }\n    return jsonObjects\n}\n\ndef parseJsonFromCodeBlocks(String text) {\n    def jsonObjects = []\n    def patterns = [/(?s)```json(.*?)```/, /(?s)```(.*?)```/]\n    \n    patterns.each { pattern ->\n        def matcher = (text =~ pattern)\n        while (matcher.find()) {\n            try {\n                def jsonStr = matcher.group(1).trim()\n                def jsonObj = com.unifyapps.infra.utils.JsonUtils.fromJson(jsonStr, Map.class)\n                if (jsonObj) jsonObjects.add(jsonObj)\n            } catch (Exception e) {\n                // Ignore parsing errors\n            }\n        }\n    }\n    return jsonObjects\n}\n\ndef findAndParseJsonObjects(String text) {\n    def jsonObjects = []\n    def potentialJsons = findAllJsonStrings(text)\n    \n    potentialJsons.each { jsonStr ->\n        // Try parsing as-is\n        try {\n            def jsonObj = com.unifyapps.infra.utils.JsonUtils.fromJson(jsonStr, Map.class)\n            jsonObjects.add(jsonObj)\n        } catch (Exception e) {\n            // Try unescaping\n            if (jsonStr.contains(\"\\\\\\\"\")) {\n                try {\n                    def unescaped = jsonStr.replace(\"\\\\\\\"\", \"\\\"\")\n                    if (unescaped.startsWith(\"\\\"\") && unescaped.endsWith(\"\\\"\")) {\n                        unescaped = unescaped.substring(1, unescaped.length() - 1)\n                    }\n                    def jsonObj = com.unifyapps.infra.utils.JsonUtils.fromJson(unescaped, Map.class)\n                    jsonObjects.add(jsonObj)\n                } catch (Exception e2) {\n                    // Try double-escaped fix\n                    try {\n                        def fixedStr = jsonStr.replace(\"\\\\\\\\\\\"\", \"\\\"\").replace(\"\\\\\\\"\", \"\\\"\")\n                        def jsonObj = com.unifyapps.infra.utils.JsonUtils.fromJson(fixedStr, Map.class)\n                        jsonObjects.add(jsonObj)\n                    } catch (Exception e3) {\n                        // Ignore\n                    }\n                }\n            }\n        }\n    }\n    return jsonObjects\n}\n\ndef findAllJsonStrings(String text) {\n    def result = []\n    def index = 0\n    \n    while (index < text.length()) {\n        def openBraceIndex = text.indexOf('{', index)\n        if (openBraceIndex == -1) break\n        \n        def closeBraceIndex = findMatchingCloseBrace(text, openBraceIndex)\n        if (closeBraceIndex == -1) {\n            index = openBraceIndex + 1\n            continue\n        }\n        \n        def jsonObject = text.substring(openBraceIndex, closeBraceIndex + 1)\n        result.add(jsonObject)\n        index = closeBraceIndex + 1\n    }\n    \n    return result\n}\n\ndef findMatchingCloseBrace(String text, int openBraceIndex) {\n    int depth = 1\n    int index = openBraceIndex + 1\n    boolean inString = false\n    boolean escaped = false\n    \n    while (index < text.length() && depth > 0) {\n        char c = text.charAt(index)\n        \n        if (escaped) {\n            escaped = false\n        } else if (c == '\\\\') {\n            escaped = true\n        } else if (c == '\"') {\n            inString = !inString\n        } else if (!inString) {\n            if (c == '{') {\n                depth++\n            } else if (c == '}') {\n                depth--\n            }\n        }\n        index++\n    }\n    \n    return depth == 0 ? index - 1 : -1\n}\n\ndef extractLargestField(List jsonObjects, String fieldName) {\n    def largestValue = null\n    def largestSize = 0\n    \n    jsonObjects.each { jsonObj ->\n        if (jsonObj.containsKey(fieldName) && jsonObj[fieldName] != null) {\n            def value = jsonObj[fieldName]\n            def valueStr = value.toString()\n            if (valueStr.length() > largestSize) {\n                largestSize = valueStr.length()\n                largestValue = value\n            }\n        }\n    }\n    \n    return largestValue\n}\n\ndef parseToolCallObject(toolCallInput) {\n    if (toolCallInput instanceof Map) {\n        return [\n            name: toolCallInput.name ?: \"\",\n            arguments: (toolCallInput.arguments instanceof Map) ? toolCallInput.arguments : [:]\n        ]\n    } else if (toolCallInput instanceof String) {\n        try {\n            def parsed = com.unifyapps.infra.utils.JsonUtils.fromJson(toolCallInput, Map.class)\n            if (parsed instanceof Map) {\n                return [\n                    name: parsed.name ?: \"\",\n                    arguments: (parsed.arguments instanceof Map) ? parsed.arguments : [:]\n                ]\n            }\n        } catch (Exception e) {\n            // Could not parse\n        }\n    }\n    return [name: \"\", arguments: [:]]\n}\n\ndef cleanJsonString(String text) {\n    if (text == null) return null\n    \n    def cleaned = text.trim()\n    \n    if (cleaned.startsWith(\"\\\"\") && cleaned.endsWith(\"\\\"\")) {\n        cleaned = cleaned.substring(1, cleaned.length() - 1)\n    }\n    \n    // Attempt to clear extraneous characters\n    cleaned = cleaned.replaceAll(\"^\\\\s*\\\":\\\\\\\"\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\\\\\"\\\\s*,?\\\\s*\\\\\\$\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\\\\\"\\\\s*\\\\}?\\\\s*\\\\\\$\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n    cleaned = cleaned.replaceAll(\"\\\\\\\\n\", \"\\n\")\n    cleaned = cleaned.replaceAll(\"\\\\\\\\\\\\\\\\\", \"\\\\\")\n    cleaned = cleaned.replaceAll(\"\\\\\\\\\\\":\\\\\\\\\\\"\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\":\\\"\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\",\\\"\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\"}\", \"\")\n    cleaned = cleaned.replaceAll(\":\\\"\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\",\", \"\")\n    cleaned = cleaned.replaceAll(\"\\\":\\\"\", \"\")\n    cleaned = cleaned.replaceAll(\": \\\"\", \"\")\n    \n    cleaned = cleaned.replaceAll(\"\\\\\\\\n\", \"\\n\")\n    cleaned = cleaned.replaceAll(\"\\\\\\n\", \"\\\\n\")\n    \n    return cleaned\n}",
				"parameters":{
					"llmResponse":"{{ n_1XNM7.outputs.llmResponse }}"
				}
			},
			"skip":false,
			"subTitle":"parse",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"utility_by_unifyapps",
				"resourceVersion":445,
				"resourceName":"utility_by_unifyapps_to_json_string",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_tGkfr-1",
			"id":"n_KF3n3",
			"index":0,
			"inputs":{
				"object":"{{ _zErEh.outputs.result.toolCall.arguments }}"
			},
			"skip":false,
			"subTitle":"toolInputs",
			"title":"Serialise object to JSON string",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":454,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_tGkfr-1",
			"id":"n_ggUk3",
			"index":0,
			"inputs":{
				"result":{
					"toolsToExecute":[
						{
							"name":"{{ _zErEh.outputs.result.toolCall.name }}",
							"arguments":"{{ n_KF3n3.outputs.result }}"
						}
					],
					"llmResponse":"{{ _zErEh.outputs.result.finalLlmResponse }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":1,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":true,
	"version":85
}