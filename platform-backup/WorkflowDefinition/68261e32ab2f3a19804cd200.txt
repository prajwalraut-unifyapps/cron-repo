{
	"appsUsed":[
		
	],
	"createdTime":1747641656396,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1759243656939,
		"deployedBy":-1,
		"deployedDefinitionId":"68dbed885e003e08cdeb310e",
		"status":"DEPLOYED",
		"version":53,
		"workflowVersion":68
	},
	"edges":[
		{
			"fromNodeId":"GSLLa",
			"priority":0,
			"skip":false,
			"toNodeId":"swrU5",
			"type":"next"
		},
		{
			"fromNodeId":"swrU5",
			"priority":0,
			"skip":false,
			"toNodeId":"BlglB",
			"type":"next"
		}
	],
	"grants":{
		"configs":[
			{
				"permissions":[
					"V"
				],
				"principalType":"GLOBAL"
			}
		]
	},
	"id":"68261e32ab2f3a19804cd200",
	"lastModifiedBy":-1,
	"lcName":"text to workflow v2 | adjacency list to graph",
	"modifiedTime":1759371974401,
	"name":"Text to Workflow v2 | Adjacency List to Graph",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":345,
				"resourceName":"callables_from_automation"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"PeKxr-1",
			"id":"GSLLa",
			"index":1,
			"inputs":{
				"result":{
					"type":"object",
					"properties":{
						"new_workflow_graph":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"New Workflow Graph"
						}
					},
					"additionalProperties":false,
					"required":[
						"new_workflow_graph"
					],
					"dynamic":true
				},
				"setup":{
					"type":"object",
					"properties":{
						"previous_workflow_graph":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Previous Workflow Graph"
						},
						"current_workflow_adj_list":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Current Workflow Adj List"
						},
						"caseId":{
							"type":"string",
							"title":"Case Id"
						}
					},
					"additionalProperties":false,
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via automation",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":349,
				"resourceName":"code_by_unifyapps_python",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"PeKxr-1",
			"id":"swrU5",
			"index":2,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"new_workflow_graph":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"new_workflow_graph"
						}
					},
					"additionalProperties":false,
					"required":[
						"new_workflow_graph"
					]
				},
				"configurationMode":"DEFAULT",
				"input":{
					"type":"object",
					"properties":{
						"workflow_adj_list":{
							"type":"object",
							"title":"workflow_adj_list"
						},
						"workflow_graph":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflow_graph"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"code":"# This snippet does:\n# 1. Convert updated adjacency list to workflow graph format\n# 2. Merge additional fields from the original graph into the updated graph\n\nimport json\nimport random\nimport string\nfrom copy import deepcopy\nfrom collections import defaultdict\nfrom typing import Any, Dict, List, Set\n\n\ndef convert_adjlist_to_workflow_graph(\n        adjlist_json: Dict[str, Any],\n        workflow_graph: Dict[str, Any] | None = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Convert an adjacency-list representation back to the normal\n    { \"nodes\": [...], \"edges\": [...] } workflow graph.\n    \"\"\"\n    import json, random, string\n    from copy import deepcopy\n    from collections import defaultdict\n    from typing import Any, Dict, List, Set\n\n    # --------------------------------------------------------------- #\n    # Helper: leaves for IF-ELSE arms – treat LOOP blocks as leaves   #\n    # --------------------------------------------------------------- #\n    def _cond_leaves(start: str) -> Set[str]:\n        \"\"\"Return terminal nodes of an IF-ELSE arm.\n        - A node of type LOOP counts as a leaf (we do not descend into its body)\n        - We ignore loop-back edges (“loopback”) when walking\n        \"\"\"\n        stack, out, seen = [start], set(), set()\n        while stack:\n            cur = stack.pop()\n            if cur in seen:\n                continue\n            seen.add(cur)\n\n            node_type = str(id2node.get(cur, {}).get(\"type\", \"\")).upper()\n            if node_type == \"LOOP\":\n                out.add(cur)\n                continue\n\n            children = [\n                tgt for tgt in (\n                    e[\"toNodeId\"] for e in graph[\"edges\"]\n                    if e[\"fromNodeId\"] == cur\n                       and e.get(\"name\") != \"loopback\"\n                       and e.get(\"type\") != \"loop\"\n                )\n                if str(id2node.get(tgt, {}).get(\"type\", \"\")).upper() != \"STOP\"\n            ]\n            if not children:\n                out.add(cur)\n            else:\n                stack.extend(children)\n        return out\n\n\n\n    # ------------------------------------------------------------------ #\n    # 1)  Rebuild nodes & edges                                           #\n    # ------------------------------------------------------------------ #\n    edge_type_map_reverse = {\n        \"next_in_default_branch\": \"default\"\n    }\n\n    # -- quick look-up for original nodes ------------------------------ #\n    original_nodes: Dict[str, Dict[str, Any]] = {}\n    if workflow_graph:\n        original_nodes = {n[\"id\"]: n for n in workflow_graph.get(\"nodes\", [])}\n\n    nodes: List[Dict[str, Any]] = []\n    edges: List[Dict[str, Any]] = []\n\n    def not_undefined(val: str | None) -> bool:\n        return val not in (None, \"\", \"placeholder\")\n\n    # ------------------------------------------------------------------ #\n    # Helper: turn an adj-list edge-type into a real graph edge           #\n    # ------------------------------------------------------------------ #\n    def make_edge(src_id: str, tgt_id: str, etype: str | None) -> Dict[str, Any]:\n        edge: Dict[str, Any] = {\n            \"fromNodeId\": src_id,\n            \"toNodeId\": tgt_id,\n            \"priority\": 0,\n            \"skip\": False\n        }\n        if src_id == tgt_id:\n            return None\n        if etype is None or etype == \"next\":\n            edge[\"type\"] = \"next\"\n            return edge\n\n        # -------- BRANCH support ---------------------------------------- #\n        if etype.startswith(\"next_in_branch_number\"):\n            num = etype.split(\"next_in_branch_number\")[-1]\n            edge[\"type\"] = \"branch\"\n            edge[\"name\"] = num\n            return edge\n        if etype.startswith(\"next_in_branch\") and etype[len(\"next_in_branch\"):].isdigit():\n            num = etype[len(\"next_in_branch\"):]\n            edge[\"type\"] = \"branch\"\n            edge[\"name\"] = num\n            return edge\n        if etype == \"next_in_default_branch\":\n            edge[\"type\"] = \"branch\"\n            edge[\"name\"] = \"default\"\n            return edge\n        if etype == \"next_after_branch_end\":\n            edge[\"type\"] = \"next_after_branch_end\"\n            return edge\n\n        # -------- LOOP support ---------------------------------------- #\n        if etype == \"next_after_loop_end\":\n            edge[\"type\"] = \"next\"\n            return edge\n        if etype == \"next_inside_loop\":\n            edge[\"type\"] = \"loop\"\n            return edge\n        if etype == \"loopback_to_loop_start\":\n            edge[\"type\"] = \"next\"\n            edge[\"name\"] = \"loopback\"\n            return edge\n\n        # -------- IF-ELSE support ------------------------------------- #\n        if etype == \"next_after_condition_end\":\n            edge[\"type\"] = \"next_after_condition_end\"\n            return edge\n        if \"condition\" in etype:\n            edge[\"type\"] = \"next\" if \"not\" in etype else \"if\"\n            edge[\"name\"] = \"no\" if \"not\" in etype else \"yes\"\n            return edge\n\n        if etype in edge_type_map_reverse:\n            edge[\"name\"] = edge_type_map_reverse[etype]\n        else:\n            edge[\"type\"] = etype\n        return edge\n\n    # ------------------------------------------------------------------ #\n    # 1)  Build / update every node, copy outgoing edges                #\n    # ------------------------------------------------------------------ #\n    for adj_node in adjlist_json.get(\"nodes\", []):\n        nid = adj_node[\"node_id\"]\n\n        # ---------- build / update the node itself --------------------- #\n        node = deepcopy(original_nodes.get(nid, {}))\n        node[\"id\"] = nid\n\n        ctx = deepcopy(node.get(\"context\", {}))\n        if not_undefined(adj_node.get(\"node_name\")):\n            ctx[\"appName\"] = adj_node[\"node_name\"]\n        if not_undefined(adj_node.get(\"action_name\")):\n            ctx[\"resourceName\"] = adj_node[\"action_name\"]\n        if ctx:\n            node[\"context\"] = ctx\n\n        for k in (\"inputs\", \"fallbackMode\", \"skip\", \"debug\",\n                  \"dirty\", \"subTitle\", \"title\", \"hidden\", \"type\"):\n            if k in adj_node and k not in node:\n                node[k] = deepcopy(adj_node[k])\n        node.setdefault(\"fallbackMode\", \"STOP\")\n        node.setdefault(\"skip\", False)\n        node.setdefault(\"debug\", False)\n        node.setdefault(\"dirty\", False)\n        node.setdefault(\"inputs\", {})\n        if \"groupId\" in adj_node:\n            node[\"groupId\"] = adj_node[\"groupId\"]\n\n        # trigger flag\n        if adj_node.get(\"triggerNode\"):\n            node.setdefault(\"trigger\", True)\n            node.setdefault(\"type\", \"START\")\n\n        # infer LOOP type when missing\n        if \"type\" not in node:\n            if any(e[\"edge_type\"] == \"next_after_loop_end\"\n                   for e in adj_node.get(\"next\", [])):\n                node[\"type\"] = \"LOOP\"\n\n        if ctx.get(\"appName\") == \"branch\":\n            node.setdefault(\"type\", \"BRANCH\")\n            node.setdefault(\"subTitle\", \"Branch\")\n            node.setdefault(\"title\", \"Branch\")\n        elif ctx.get(\"appName\") == \"branch_condition\":\n            node.setdefault(\"type\", \"BRANCH_CONDITION\")\n            node.setdefault(\"hidden\", True)\n            node.setdefault(\"title\", \"Branch Condition\")\n\n        nodes.append(node)\n\n        # ------------- edges from this node --------------------------- #\n        node_type = str(node.get(\"type\", \"\")).upper()\n        next_entries = adj_node.get(\"next\", [])\n\n        # Decide if this is an IF-ELSE root even when 'type' is absent\n        is_if_else = (\n                node_type == \"IF_ELSE\" or\n                any(e[\"edge_type\"].startswith(\"next_if_\")\n                    or e[\"edge_type\"] == \"next_after_condition_end\"\n                    for e in next_entries)\n        )\n\n        if not is_if_else:\n            # -------- ordinary node – previous behaviour --------------- #\n            for out in next_entries:\n                if out[\"edge_type\"] == \"next_after_condition_end\":\n                    continue  # ignore everywhere else\n                edge = make_edge(nid, out[\"node_id\"], out[\"edge_type\"])\n                if edge:\n                    edges.append(edge)\n            continue\n\n        # ---- IF-ELSE handling  ---------------------------- #\n        yes_found = no_found = False\n        after_end_target = None\n\n        for out in next_entries:\n            etype = out[\"edge_type\"]\n            if etype == \"next_if_condition_match\":\n                yes_found = True\n                edge = make_edge(nid, out[\"node_id\"], out[\"edge_type\"])\n                if edge:\n                    edges.append(edge)\n            elif etype == \"next_if_not_condition_match\":\n                no_found = True\n                edge = make_edge(nid, out[\"node_id\"], out[\"edge_type\"])\n                if edge:\n                    edges.append(edge)\n            elif etype == \"next_after_condition_end\":\n                after_end_target = out[\"node_id\"]  # remember only\n\n            else:  # any other edge\n                edge = make_edge(nid, out[\"node_id\"], out[\"edge_type\"])\n                if edge:\n                    edges.append(edge)\n\n        # ----- synthesise a missing branch when required ---------------- #\n        if after_end_target and not (yes_found and no_found):\n            # At least one arm is empty → root must point straight to after_end\n            if not yes_found:  # YES arm is empty\n                tempedg = make_edge(nid,\n                                    after_end_target,\n                                    \"next_if_condition_match\")  # → type=if, name=yes\n                if tempedg:\n                    edges.append(tempedg)\n            if not no_found:  # NO arm is empty\n                tempedg = make_edge(nid,\n                                    after_end_target,\n                                    \"next_if_not_condition_match\")  # → type=next, name=no\n                if tempedg:\n                    edges.append(tempedg)\n\n        else:  # when we have Yes and No and after_end_target branch\n            tempedg = make_edge(nid, after_end_target, \"next_after_condition_end\")\n            if tempedg:\n                edges.append(tempedg)\n\n        # If both YES+NO present we drop the after-condition edge anyway.\n\n    graph = {\"nodes\": nodes, \"edges\": edges}\n\n\n\n    # ------------------------------------------------------------------ #\n    #  BRANCH post-processing\n    # ------------------------------------------------------------------ #\n    graph: Dict[str, Any] = {\"nodes\": nodes, \"edges\": edges}\n    id2node = {n[\"id\"]: n for n in graph[\"nodes\"]}\n\n    branch_roots: Dict[str, List[Dict[str, Any]]] = defaultdict(list)\n    for e in graph[\"edges\"]:\n        if e.get(\"type\") == \"branch\":\n            branch_roots[e[\"fromNodeId\"]].append(e)\n\n    adj: Dict[str, List[str]] = defaultdict(list)\n    for e in graph[\"edges\"]:\n       # skip loopbacks **and** edges that go into a loop body\n        if e.get(\"name\") == \"loopback\" or e.get(\"type\") == \"loop\":\n            continue\n        adj[e[\"fromNodeId\"]].append(e[\"toNodeId\"])\n\n    def _leaves(start: str) -> Set[str]:\n        stk, out, seen = [start], set(), set()\n        while stk:\n            cur = stk.pop()\n            if cur in seen:\n                continue\n            seen.add(cur)\n            nxt = adj.get(cur, [])\n            if not nxt:\n                out.add(cur)\n            else:\n                stk.extend(nxt)\n        return out\n\n    for root_id, arm_edges in branch_roots.items():\n        root_node = id2node[root_id]\n\n        # --- find converge node and keep track of arms  ---------------\n        after_end_edge = next(\n            (e for e in graph[\"edges\"]\n             if e[\"fromNodeId\"] == root_id and e.get(\"type\") == \"next_after_branch_end\"),\n            None\n        )\n        after_end_target = after_end_edge[\"toNodeId\"] if after_end_edge else None\n\n        has_default_arm = any(e.get(\"name\") == \"default\" for e in arm_edges)\n        if after_end_edge and not has_default_arm:\n            default_edge = {\n                \"fromNodeId\": root_id,\n                \"toNodeId\": after_end_target,\n                \"priority\": 0,\n                \"skip\": False,\n                \"type\": \"branch\",\n                \"name\": \"default\",\n            }\n            graph[\"edges\"].append(default_edge)\n            arm_edges.append(default_edge)\n            has_default_arm = True\n            # drop the technical edge – it has been replaced\n            graph[\"edges\"].remove(after_end_edge)\n            after_end_edge = None\n        # ---------- connect leaves -----------------------------------\n        if after_end_target:\n            for arm in arm_edges:\n                if arm.get(\"name\") == \"default\" and arm[\"toNodeId\"] == after_end_target:\n                    continue\n                for leaf in _leaves(arm[\"toNodeId\"]):\n                    if not any(ed[\"fromNodeId\"] == leaf and\n                               ed[\"toNodeId\"] == after_end_target\n                               for ed in graph[\"edges\"]):\n                        edge = make_edge(leaf, after_end_target, None)\n                        if edge:\n                            graph[\"edges\"].append(edge)\n\n        else:\n            ph_id = f\"{root_id}\"\n            if ph_id not in id2node:\n                ph_node = {\n                    \"id\": ph_id,\n                    \"context\": {\"appName\": \"placeholder\"},\n                    \"fallbackMode\": \"STOP\",\n                    \"skip\": False,\n                    \"debug\": False,\n                    \"dirty\": False,\n                    \"inputs\": {},\n                    \"type\": \"ACTION\",\n                    \"title\": \"Select an app and action\"\n                }\n                graph[\"nodes\"].append(ph_node)\n                id2node[ph_id] = ph_node\n\n            for arm in arm_edges:\n                for leaf in _leaves(arm[\"toNodeId\"]):\n                    if not any(ed[\"fromNodeId\"] == leaf and\n                               ed[\"toNodeId\"] == ph_id for ed in graph[\"edges\"]):\n                        e = make_edge(leaf, ph_id, None)\n                        if e:\n                            graph[\"edges\"].append(e)\n\n            for ed in graph[\"edges\"]:\n                if ed[\"fromNodeId\"] == root_id and ed.get(\"type\") == \"next\":\n                    ed[\"fromNodeId\"] = ph_id\n\n\n\n        # ---------- rebuild inputs.branches ---------------------------\n        branches_cfg = []\n        for ed in sorted(arm_edges,\n                         key=lambda x: (x[\"name\"] != \"default\", x[\"name\"])):\n            arm_id = ed[\"name\"]\n            if arm_id == \"default\":\n                branches_cfg.append({\"id\": \"default\"})\n            else:\n                branches_cfg.append({\n                    \"id\": arm_id,\n                    \"inputs\": {\"name\": f\"Branch {arm_id}\"}\n                })\n                bc_id = f\"{root_id}@{arm_id}\"\n                if bc_id not in id2node:\n                    bc_node = {\n                        \"id\": bc_id,\n                        \"type\": \"BRANCH_CONDITION\",\n                        \"hidden\": True,\n                        \"fallbackMode\": \"STOP\",\n                        \"skip\": False,\n                        \"debug\": False,\n                        \"dirty\": False,\n                        \"title\": \"Branch Condition\",\n                        \"context\": {\n                            \"appName\": \"branch_condition\",\n                            \"resourceName\": \"branch_condition\",\n                            \"resourceVersion\": 0,\n                            \"type\": \"APPLICATION\"\n                        },\n                        \"inputs\": {\"name\": f\"Branch {arm_id}\"}\n                    }\n                    graph[\"nodes\"].append(bc_node)\n                    id2node[bc_id] = bc_node\n                    first_real = ed[\"toNodeId\"]\n                    ed[\"toNodeId\"] = bc_id\n                    e = make_edge(bc_id, first_real, None)\n                    if e:\n                        graph[\"edges\"].append(e)\n\n        if not any(b.get(\"id\") == \"default\" for b in branches_cfg):\n            branches_cfg.append({\"id\": \"default\"})\n\n        root_node.setdefault(\"inputs\", {})[\"branches\"] = branches_cfg\n        node.setdefault(\"groupId\", \"\")\n\n    # ------------------------------------------------------------------ #\n    #  IF-ELSE post-processing                                           #\n    # ------------------------------------------------------------------ #\n    for cond_node in graph[\"nodes\"]:\n        if cond_node.get(\"type\") != \"IF_ELSE\":\n            continue\n        root_id = cond_node[\"id\"]\n\n        # Does the root currently have a next_after_condition_end edge?\n        after_edge = next(\n            (e for e in graph[\"edges\"]\n             if e[\"fromNodeId\"] == root_id and e.get(\"type\") == \"next_after_condition_end\"),\n            None\n        )\n        if not after_edge:\n            continue  # nothing to fix for this IF-ELSE\n\n        after_target = after_edge[\"toNodeId\"]\n\n        # Which arms exist\n        yes_targets = [\n            e[\"toNodeId\"] for e in graph[\"edges\"]\n            if e[\"fromNodeId\"] == root_id and e.get(\"name\") == \"yes\"\n        ]\n        no_targets = [\n            e[\"toNodeId\"] for e in graph[\"edges\"]\n            if e[\"fromNodeId\"] == root_id and e.get(\"name\") == \"no\"\n        ]\n\n        has_yes = bool(yes_targets)\n        has_no = bool(no_targets)\n\n        if has_yes and has_no:\n            # 1) remove the technical edge from the root\n            graph[\"edges\"].remove(after_edge)\n\n            # 2) add next edges from leaves of *each* arm to after_target\n            for arm_root in yes_targets + no_targets:\n                for leaf in _cond_leaves(arm_root):\n                    if not any(ed[\"fromNodeId\"] == leaf and\n                               ed[\"toNodeId\"] == after_target\n                               for ed in graph[\"edges\"]):\n                        graph[\"edges\"].append(make_edge(leaf, after_target, None))\n                        # remove any other plain-next edges leaving this leaf\n                        graph[\"edges\"] = [\n                            ed for ed in graph[\"edges\"]\n                            if not (\n                                ed[\"fromNodeId\"] == leaf\n                                and ed[\"type\"] == \"next\"\n                                and ed[\"toNodeId\"] != after_target\n                            )\n                        ]\n        else:\n            # Only one arm present – label the edge to show which arm is empty\n            if not has_yes:  # YES path missing\n                after_edge[\"type\"] = \"if\"\n                after_edge[\"name\"] = \"yes\"\n            else:  # NO path missing\n                after_edge[\"type\"] = \"next\"\n                after_edge[\"name\"] = \"no\"\n                \n    \n\n    for node in graph[\"nodes\"]:\n        if node.get(\"type\", \"\") == \"BRANCH\" and \"inputs\" in node and \"branches\" in node[\"inputs\"]:\n            branches = node[\"inputs\"][\"branches\"]\n            branches = sorted(branches, key=lambda x: x[\"id\"])\n            node[\"inputs\"][\"branches\"] = branches\n\n    for edge in edges:\n        if (edge.get(\"type\",\"\") == \"next_after_condition_end\"\n                or edge.get(\"type\",\"\") == \"next_after_branch_end\"\n                or edge.get(\"type\",\"\") == \"next_after_loop_end\"):\n            edge[\"type\"] = \"next\"\n\n    return graph\n\n\nnew_workflow_graph = convert_adjlist_to_workflow_graph(workflow_adj_list, workflow_graph)\nresult = {\n    'new_workflow_graph': new_workflow_graph\n}",
				"isAsync":false,
				"python_version":"3.12",
				"parameters":{
					"workflow_adj_list":"{{ GSLLa.outputs.current_workflow_adj_list }}",
					"workflow_graph":"{{ GSLLa.outputs.previous_workflow_graph }}"
				}
			},
			"skip":false,
			"subTitle":"Code",
			"title":"Execute Python script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":351,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"PeKxr-1",
			"id":"BlglB",
			"index":3,
			"inputs":{
				"result":{
					"new_workflow_graph":"{{ swrU5.outputs.result.new_workflow_graph }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":39717,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":true,
	"tags":[
		"Text_to_Workflow_v2"
	],
	"version":69
}